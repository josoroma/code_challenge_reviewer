

# src/agents.py




## Project Name
code_challenge_reviewer

## Path
src/agents.py

## Explain This
This script defines a class `Agents` which creates and manages different types of agents used for code reviews, file path extraction, and content retrieval using the GitHub API. It employs logging for error handling and defines a `StreamToExpander` class that processes output data, filtering ANSI codes and managing buffered content for display in a Streamlit application.

## Code Review
The code exhibits a clear structure with well-defined classes and methods. However, several areas could be improved for better code quality and adherence to best practices:

1. **Code Quality**: The overall quality is good, but there are some areas where readability could be enhanced, such as by simplifying complex expressions and improving variable names.
  
2. **Bugs**: No direct bugs were identified. However, the logging in exception handling does not provide context about the error's origin beyond the message, which could make debugging harder.

3. **Anti-Patterns**: 
   - Use of hardcoded strings for roles and goals could lead to maintainability issues. Consider using constants or configuration files.
   - The `write` method in `StreamToExpander` has a complex conditional structure that can be simplified for better readability.

4. **Improvements**: 
   - Enhance the logging to include the method name or the context of the operation that failed.
   - The regular expressions used for filtering and extracting tasks could be optimized for efficiency.
   - Adding type hints to method signatures would improve code readability and maintainability.

5. **Compliance**: The code uses logging appropriately, but it could benefit from more comprehensive comments and docstrings that explain the purpose and usage of each method and class more clearly.

6. **General Recommendations**:
   - Consider implementing unit tests for methods to ensure they function as expected.
   - Use a linter to catch potential style issues and enforce coding standards.

## Updated Code
```python
import re
import logging
from crewai import Agent
import streamlit as st
from tools import Tools

# Set up logging configuration
logging.basicConfig(level=logging.ERROR, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

class Agents:
    """
    Class to create and manage different types of agents.
    """

    REVIEW_AGENT_ROLE = 'Senior Software Developer'
    REVIEW_AGENT_GOAL = 'Perform detailed code reviews on the provided file to ensure it adheres to industry code quality standards. The code review should focus on the following aspects: evaluate code quality, identify bugs, spot anti-patterns, recommend improvements and ensure compliance.'
    REVIEW_AGENT_BACKSTORY = "You are a Senior Software Developer at a leading tech company, responsible for maintaining high code quality standards across the organization."

    PATH_AGENT_ROLE = "File Path Extractor"
    PATH_AGENT_GOAL = "Get the tree structure of folder and return full paths of the given file or files of given folder in array format."
    PATH_AGENT_BACKSTORY = "You're a file path extractor who has created several file paths from given tree structures."

    CONTENT_AGENT_ROLE = "GitHub API Expert"
    CONTENT_AGENT_GOAL = "Get the content of given file using GitHub API."
    CONTENT_AGENT_BACKSTORY = "You're a GitHub API expert who has extracted many file contents using GitHub's API."

    def review_agent(self) -> Agent:
        """
        Creates a review agent for code reviews.

        Returns:
            Agent: Configured agent for performing code reviews.
        """
        try:
            return Agent(
                role=self.REVIEW_AGENT_ROLE,
                goal=self.REVIEW_AGENT_GOAL,
                backstory=self.REVIEW_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error("Error creating review agent: %s", str(e), exc_info=True)
            return None

    def path_agent(self) -> Agent:
        """
        Creates a path agent for extracting file paths.

        Returns:
            Agent: Configured agent for extracting file paths.
        """
        try:
            return Agent(
                role=self.PATH_AGENT_ROLE,
                goal=self.PATH_AGENT_GOAL,
                backstory=self.PATH_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error("Error creating path agent: %s", str(e), exc_info=True)
            return None

    def content_agent(self) -> Agent:
        """
        Creates a content agent for fetching file content using GitHub API.

        Returns:
            Agent: Configured agent for fetching file content using GitHub API.
        """
        try:
            return Agent(
                role=self.CONTENT_AGENT_ROLE,
                goal=self.CONTENT_AGENT_GOAL,
                backstory=self.CONTENT_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
                tools=[Tools.get_file_contents],
            )
        except Exception as e:
            logging.error("Error creating content agent: %s", str(e), exc_info=True)
            return None

class StreamToExpander:
    def __init__(self, expander):
        self.expander = expander
        self.buffer = []
        self.colors = ['red', 'green', 'blue', 'orange']  # Define a list of colors
        self.color_index = 0  # Initialize color index

    def write(self, data: str):
        """
        Writes data to the expander after cleaning ANSI escape codes and checking for task information.
        
        Args:
            data (str): The data to write to the expander.
        """
        # Filter out ANSI escape codes using a regular expression
        cleaned_data = re.sub(r'\x1B\[[0-9;]*[mK]', '', data)

        # Use a single regex to capture task information
        task_match = re.search(r'task\s*:\s*["\']?([^"\']+)["\']?', cleaned_data, re.IGNORECASE)

        if task_match:
            task_value = task_match.group(1).strip()
            st.toast(":robot_face: " + task_value)

        self.buffer.append(cleaned_data)

        if "\n" in data:
            self.expander.code(''.join(self.buffer), language='bash')
            self.buffer = []

    def clear_buffer(self):
        """Clears the buffer to free memory."""
        self.buffer = []
```


