

# src/agents.py



my best complete final answer to the task.

 output
## Project Name: code_challenge_reviewer

## Path: src/agents.py

## Explain This
The `agents.py` module defines a class `Agents` that provides methods for creating different types of agents: a review agent for code reviews, a path agent for extracting file paths, and a content agent for fetching file content using the GitHub API. Additionally, the module includes a `StreamToExpander` class that processes and logs data, filtering out ANSI escape codes and displaying task-related messages in a Streamlit expander.

## Code Review

### Code Quality
- Overall, the code is well-structured and readable.
- Docstrings are provided for classes and methods, enhancing readability and maintainability.

### Bugs
- No bugs were identified in the provided code.

### Anti-Patterns
1. **Hardcoded Strings**: The code contains hardcoded role names, goals, and backstories. Consider moving these to a configuration file or constants module.
2. **Exception Handling**: The `except Exception as e` clauses log the error but do not provide any fallback mechanism or user notification.

### Improvements
1. **Logging**: Improve the logging mechanism to include different levels (INFO, WARNING, ERROR) as appropriate.
2. **Configuration Management**: Move hardcoded strings to a configuration file or constants module.
3. **Exception Handling**: Enhance exception handling to include user notifications and fallback mechanisms where applicable.
4. **Buffer Handling in `StreamToExpander`**: Ensure that buffered data is handled properly to avoid potential memory leaks.

### Compliance
- The code largely adheres to industry standards and best practices.
- The logging configuration is set up correctly.
- The use of regular expressions for filtering ANSI escape codes and extracting task information is appropriate.

## Updated Code

```python
import re
import logging
from crewai import Agent
import streamlit as st
from tools import Tools

# Set up logging configuration
logging.basicConfig(level=logging.ERROR, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Define constants for agent roles, goals, and backstories
REVIEW_AGENT_ROLE = 'Senior Software Developer'
REVIEW_AGENT_GOAL = 'Perform detailed code reviews on the provided file to ensure it adheres to industry code quality standards. The code review should focus on the following aspects: evaluate code quality, identify bugs, spot anti-patterns, recommend improvements and ensure compliance.'
REVIEW_AGENT_BACKSTORY = "You are a Senior Software Developer at a leading tech company, responsible for maintaining high code quality standards across the organization. As part of your role, you are tasked with conducting thorough code reviews on given file contents. Your goal is to ensure the code meets industry standards and follows best practices specific to the technologies in use."

PATH_AGENT_ROLE = "File Path Extractor"
PATH_AGENT_GOAL = "Get the tree structure of folder and return full paths of the given file or files of given folder in array format"
PATH_AGENT_BACKSTORY = "You're a file path extractor who has created several file paths from given tree structures"

CONTENT_AGENT_ROLE = "GitHub API Expert"
CONTENT_AGENT_GOAL = "Get the content of given file using GitHub API"
CONTENT_AGENT_BACKSTORY = "You're a GitHub API expert who has extracted many file contents using GitHub's API"

class Agents:
    """
    Class to create and manage different types of agents.
    """

    def review_agent(self):
        """
        Creates a review agent for code reviews.

        Returns:
            Agent: Configured agent for performing code reviews.
        """
        try:
            return Agent(
                role=REVIEW_AGENT_ROLE,
                goal=REVIEW_AGENT_GOAL,
                backstory=REVIEW_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error("Error creating review agent", exc_info=True)
            return None

    def path_agent(self):
        """
        Creates a path agent for extracting file paths.

        Returns:
            Agent: Configured agent for extracting file paths.
        """
        try:
            return Agent(
                role=PATH_AGENT_ROLE,
                goal=PATH_AGENT_GOAL,
                backstory=PATH_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error("Error creating path agent", exc_info=True)
            return None

    def content_agent(self):
        """
        Creates a content agent for fetching file content using GitHub API.

        Returns:
            Agent: Configured agent for fetching file content using GitHub API.
        """
        try:
            return Agent(
                role=CONTENT_AGENT_ROLE,
                goal=CONTENT_AGENT_GOAL,
                backstory=CONTENT_AGENT_BACKSTORY,
                verbose=True,
                allow_delegation=False,
                tools=[Tools.get_file_contents],
            )
        except Exception as e:
            logging.error("Error creating content agent", exc_info=True)
            return None

class StreamToExpander:
    def __init__(self, expander):
        self.expander = expander
        self.buffer = []
        self.colors = ['red', 'green', 'blue', 'orange']  # Define a list of colors
        self.color_index = 0  # Initialize color index

    def write(self, data):
        # Filter out ANSI escape codes using a regular expression
        cleaned_data = re.sub(r'\x1B\[[0-9;]*[mK]', '', data)

        # Check if the data contains 'task' information
        task_match_object = re.search(r'\"task\"\s*:\s*\"(.*?)\"', cleaned_data, re.IGNORECASE)
        task_match_input = re.search(r'task\s*:\s*([^\n]*)', cleaned_data, re.IGNORECASE)

        task_value = None

        if task_match_object:
            task_value = task_match_object.group(1)
        elif task_match_input:
            task_value = task_match_input.group(1).strip()

        if task_value:
            st.toast(":robot_face: " + task_value)

        self.buffer.append(cleaned_data)

        if "\n" in data:
            self.expander.code(''.join(self.buffer), language='bash')
            self.buffer = []

    def clear_buffer(self):
        """Clears the buffer to free memory."""
        self.buffer = []
```





# src/constants.py



my best complete final answer to the task.


## Project Name: code_challenge_reviewer

## Path: src/constants.py

## Explain This
This file (`constants.py`) is used for defining constants that are used throughout the codebase. These constants include URLs, file paths, directory structures, and output formats related to the application repository. This helps centralize these values, making it easier to manage and update them.

## Code Review

### Code Quality
- The code quality is generally acceptable; it uses descriptive variable names and is easy to read.
- However, there are some duplicate constants which can be cleaned up to maintain consistency.

### Bugs
- No obvious bugs are present in the code, as it is primarily defining constants.

### Anti-Patterns
- **Duplication**: The constant `APP_REPO_PATH` is defined twice with the same value. This is unnecessary and can lead to maintenance issues in the future.

### Improvements
- **Remove Duplicates**: Remove the duplicated definition of `APP_REPO_PATH`.
- **Constant Grouping**: Group related constants together and add comments to describe each group for better readability.
- **Compliance**: Ensure constants are uppercase and use underscores for word separation, which is already correctly followed.

### Compliance
- The code adheres to Python's naming conventions for constants (all uppercase with underscores).
- However, a comment structure or docstring at the top to describe the purpose of the constants file could improve clarity.

## Updated Code

```python
# Constants related to the application repository
APP_REPO_URL = "https://github.com/josoroma/code_challenge_reviewer"
APP_REPO_PATH = "src/agents.py"
APP_REPO_FILE_SAMPLE = "agents.py"
APP_REPO_FULLPATH_SAMPLE = "src/agents.py"

# Constants defining the repository structure
APP_REPO_STRUCTURE = """
- src
  - agents.py
  - main.py
  - tools.py
"""

# Sample output format for the repository
APP_REPO_OUTPUT = "['src/agents.py', 'src/main.py', 'tools.py']"
```





# src/github_helper.py



my best complete final answer to the task.


## Project Name: code_challenge_reviewer

## Path: src/github_helper.py

## Explain This:
The `github_helper.py` script is designed to fetch and display the tree structure of a GitHub repository. It uses the GitHub API to retrieve the contents of a specified repository and recursively lists files and directories, up to a maximum depth. The script also handles various HTTP errors and logs messages for debugging purposes.

## Code Review:
### Code Quality:
- The code is generally well-structured and readable.
- Function and variable names are clear and descriptive.
- Docstrings are provided for the main function, which is good for understanding its purpose and parameters.

### Bugs:
- No explicit bugs were found in the code. However, the script's behavior when the `GITHUB_KEY` is not set or the API rate limit is exceeded should be carefully tested.

### Anti-Patterns:
- **Magic Numbers**: The `max_depth` default value of 10 is a magic number. It would be better to define it as a constant.
- **Nested Try-Except Blocks**: The use of multiple `except` blocks can be simplified for better readability.
- **Hardcoding Ignored Directories**: The directories to ignore are hardcoded. Consider allowing these to be passed as parameters.

### Improvements:
- **Constants for Magic Numbers**: Define constants for magic numbers, such as `MAX_DEPTH = 10`.
- **Parameterize Ignored Directories**: Allow the list of ignored directories to be passed as an argument to the function.
- **Enhanced Error Handling**: Consolidate exception handling to reduce redundancy.
- **Logging Levels**: Differentiate between error levels (e.g., `logging.warning` for less severe issues).

### Compliance:
- The code mostly adheres to PEP 8 standards.
- Logging and exception handling are implemented, which is a good practice.
- The script uses environment variables for sensitive information, complying with security best practices.

## Updated Code:
```python
import os
import requests
import streamlit as st
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)

# Constants
MAX_DEPTH = 10
IGNORE_DIRS = {'public', 'images', 'media', 'assets'}

# Ensure environment variable is set for GITHUB_KEY
GITHUB_KEY = os.getenv('GITHUB_KEY')
if not GITHUB_KEY:
    logging.error("GITHUB_KEY environment variable not set.")
    raise ValueError("GITHUB_KEY environment variable not set.")

def get_file_tree(owner: str, repo: str, path: str = "", level: int = 0, max_depth: int = MAX_DEPTH, ignore_dirs: set = IGNORE_DIRS) -> str:
    """
    Fetch and print the tree structure of a GitHub repository, ignoring specific folders.

    Parameters:
    - owner: The username of the repository owner.
    - repo: The name of the repository.
    - path: The path to fetch. Leave empty to fetch the root directory.
    - level: The current depth in the tree structure.
    - max_depth: The maximum depth to recurse into directories.
    - ignore_dirs: A set of directories to ignore.

    Returns:
    - str: The tree structure as a string.
    """
    if level > max_depth:
        return ""

    api_url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"
    headers = {'Authorization': f'token {GITHUB_KEY}'}

    output = ""

    try:
        # Make the request
        response = requests.get(api_url, headers=headers, verify=True)
        response.raise_for_status()
        items = response.json()

        if isinstance(items, list):
            for item in items:
                # Skip ignored directories
                if item['name'] in ignore_dirs:
                    continue

                item_name = f"{' ' * (level * 2)}- {item['name']}"
                output += f"{item_name}\n"

                if item['type'] == 'dir':
                    output += get_file_tree(owner, repo, item['path'], level + 1, max_depth, ignore_dirs)

        return output

    except requests.exceptions.RequestException as req_err:
        logging.error(f"Request error: {req_err}")
        return ""
    except ValueError:
        logging.error("Error: Unable to parse the response from GitHub.")
        return ""
    except Exception as e:
        logging.error(f"Unexpected error occurred: {str(e)}")
        return ""
```

 output



# src/review_crew.py



my best complete final answer to the task.


## Project Name: code_challenge_reviewer
## Path: src/review_crew.py

### Explain This:
The `ReviewCrew` class handles the process of reviewing files in a GitHub repository. It initializes with the repository details, runs the review process using predefined agents and tasks, and appends the review results to a markdown file. The review process involves using agents to analyze the file content and review it, then aggregating the results and writing them to an output file. Logging is used to capture any errors during the process.

### Code Review:
#### Code Quality:
- The code is well-structured and organized, with clear separation of concerns between initialization, running the review, and appending results to a file.
- Docstrings are provided for methods, which enhances readability and maintainability.

#### Bugs:
- No apparent bugs are present in the code. However, error handling could be more descriptive to help with debugging.

#### Anti-Patterns:
- Using bare `except` clauses can catch unexpected errors and hide the actual issue. It's better to catch specific exceptions.
- The `try-except` block in the `run` method is too broad. It wraps too much code, making it hard to pinpoint where an error occurred.

#### Improvements:
- The `output_placeholder` is initialized but not used effectively. Consider removing or utilizing it properly.
- The `append_review_to_file` method should handle potential file I/O errors more gracefully and provide more specific error messages.

#### Compliance:
- The code follows PEP 8 standards for naming conventions and formatting.
- Logging is used appropriately to track errors and other significant events.

### Updated Code:
```python
import os
import re
import streamlit as st
import logging
from crewai import Crew
from agents import Agents
from tasks import Tasks

# Create a custom logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# Create handlers
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)

# Create formatters and add them to the handlers
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)

# Add handlers to the logger
logger.addHandler(console_handler)


class ReviewCrew:
    """
    Class to handle the review process for a given file in a GitHub repository.
    """

    def __init__(self, owner, repo, path, output):
        """
        Initializes the ReviewCrew with the repository details.

        Parameters:
            owner (str): The owner of the repository.
            repo (str): The name of the repository.
            path (str): The path of the file to review.
            output (str): The path of the single file with all the repo files reviewed.
        """
        self.owner = owner
        self.repo = repo
        self.path = path
        self.output = output
        self.output_placeholder = st.empty()

    def append_review_to_file(self, result):
        """
        Appends the explain and the review result to a markdown file.

        Parameters:
            result (str): The str containing the explain and the review results in markdown format.
        """
        # Create directory path using owner and repo
        dir_path = os.path.join(self.owner, self.repo)
        os.makedirs(dir_path, exist_ok=True)

        # Create a file with the current date as its name
        file_path = os.path.join(dir_path, self.output)

        try:
            with open(file_path, 'a') as file:
                file.write(f"\n\n# {self.repo} - {self.path}\n\n")
                file.write(result)
        except IOError as e:
            logger.error(f"IOError writing to file: {e}")
        except Exception as e:
            logger.error(f"Unexpected error writing to file: {e}")

    def run(self):
        """
        Runs the review process using the defined agents and tasks.
        """
        try:
            # The Agents
            agents = Agents()
            review_agent = agents.review_agent()
            content_agent = agents.content_agent()

            # The Tasks
            tasks = Tasks()
            content_task = tasks.content_task(
                agent=content_agent,
                owner=self.owner,
                repo=self.repo,
                path=self.path
            )
            review_task = tasks.review_task(
                agent=review_agent,
                repo=self.repo,
                path=self.path,
                context=[content_task]
            )

            # The Crew
            crew = Crew(
                agents=[content_agent, review_agent],
                tasks=[content_task, review_task],
                verbose=2,
                telemetry=False
            )

            # Run the crew
            kickoff_result = crew.kickoff()

            str_result = str(kickoff_result).strip()

            result = re.sub(r'^|```$', '', str_result, flags=re.DOTALL)

            self.append_review_to_file(f"\n\n{result}\n\n")

            self.output_placeholder.code(f"\n\n{result}\n\n", language='markdown')

            return result

        except (AttributeError, ValueError) as e:
            logger.error(f"AttributeError or ValueError running ReviewCrew: {e}")
        except Exception as e:
            logger.error(f"Unexpected error running ReviewCrew: {e}")
```




# src/tasks.py



my best complete final answer to the task.

 output
## Project Name: code_challenge_reviewer

## Path: src/tasks.py

## Explain This:
This `tasks.py` file defines a `Tasks` class that encapsulates methods for creating and managing different types of tasks using the `crewai` library. The class has three methods:
1. `review_task`: Creates a review task for a given file and returns a configured `Task` object.
2. `get_file_path_task`: Creates a task to get the file path from a given tree structure and returns a configured `Task` object.
3. `content_task`: Creates a task to fetch file content using the GitHub API and returns a configured `Task` object.

## Code Review:

### Code Quality:
- The code is well-structured and modular, with each method clearly defined to handle specific tasks.
- Docstrings are provided for each method, explaining the parameters and return values, which is good for maintainability and readability.

### Bugs:
- There are no apparent bugs in the code.

### Anti-Patterns:
- The use of multiple `import` statements for the same module (`crewai`) can be consolidated.
- The error handling could be more specific. Currently, it catches all exceptions which can sometimes hide the underlying issue.

### Improvements:
1. **Consolidate Imports**:
   ```python
   from crewai import Task, Agent
   ```
2. **Specific Exception Handling**:
   - Instead of catching all exceptions, catch specific exceptions where possible.
   - For example, catching `ImportError` or `AttributeError` specifically could provide more insight during debugging.

### Compliance:
- The code adheres to PEP 8 standards, including naming conventions and spacing.
- Proper logging is used for error tracking.

## Updated Code:
```python
from crewai import Task, Agent
import logging

class Tasks:
    """
    Class to create and manage different types of tasks.
    """

    def review_task(self, agent: Agent, repo: str, path: str, context: str) -> Task:
        """
        Creates a review task for a given file.

        Parameters:
            agent (Agent): The agent responsible for performing the review.
            repo (str): The name of the repository.
            path (str): The file path.
            context (str): The context for the task.

        Returns:
            Task: Configured task for performing the review.
        """
        try:
            return Task(
                agent=agent,
                description=f"""
                    Review the given file and provide detailed feedback and a code review to ensure it adheres to industry code quality standards.

                    - Take the file path and file contents from `content_agent`.
                    - Provide a detailed code review with feedback on the following aspects:
                       * Code Quality
                       * Bugs
                       * Anti-Patterns
                       * Improvements
                       * Compliance
                    - Make necessary improvements to the file content and return the updated content as `updated_code`.

                    Return the following values in the markdown content output:

                    - Project Name: {repo}.
                    - Path: {path}.
                    - Explain This: generate documentation for this code, explain the entire code in a few lines.
                    - Code Review: detailed explain the code review for this code, provide feedback on the code quality, bugs, anti-patterns, improvements, and compliance.
                    - Updated Code: updated code of file after making code review and changes.

                    The attributes returned must be in markdown format, as heading h2 or ## and the value as its nested text.

                    The `Updated Code` output string must be a string in python format. This `Updated Code` output string should be involved by backticks such as ```python updated_code_output ```.

                    Only return the explained and reviewed file content. If there are multiple explains and reviews, return the entire reviewed file content in markdown format.

                    Task output must be a string in markdown format and ensure the markdown content is accurate and well-structured.
                """,
                context=context,
                expected_output="Only return the string output in markdown format and ensure the markdown content is accurate and well-structured."
            )
        except Exception as e:
            logging.error(f"Error creating review task: {e}")
            return None

    def get_file_path_task(self, agent: Agent, file_tree: str, repo_directory: str, repo_structure: str, repo_file_sample: str, repo_fullpath_sample: str, repo_output_sample: str) -> Task:
        """
        Creates a task to get the file path from a given tree structure.

        Parameters:
            agent (Agent): The agent responsible for performing the task.
            file_tree (str): The tree structure of the folder.
            repo_directory (str): The user input (file or folder name).

        Returns:
            Task: Configured task for extracting file paths.
        """
        try:
            return Task(
                agent=agent,
                description=f"""
                    You are given a tree structure of folder and repo_directory. First, you have to decide whether it is a folder or file from the given tree structure of a folder.

                    Follow this approach:

                    - If it's a file then return array with 1 element which contains the full path of that file in this folder structure.
                    - If it's a folder then return array of paths of sub files inside that folder. If there is a subfolder in given folder, then return paths for those files as well.
                    - If repo_directory is not present in given tree structure then just return an empty array.

                    Please return the FULL path of a given file in the given folder tree structure. For example, if the tree structure looks like this:

                    {repo_structure}

                    Then the full path of {repo_file_sample} will be "{repo_fullpath_sample}".

                    DON'T send every file content at once, send it one by one to review_agent.

                    Here is the tree structure of the folder:

                    {file_tree}

                    Here is user input:

                    {repo_directory}

                    NOTE: ONLY RETURN ARRAY OF PATHS WITHOUT ANY EXTRA TEXT IN RESPONSE.
                """,
                expected_output=f"""
                    ONLY an array of paths.
                    For example:
                    {repo_output_sample}
                """
            )
        except Exception as e:
            logging.error(f"Error creating file path task: {e}")
            return None

    def content_task(self, agent: Agent, owner: str, repo: str, path: str) -> Task:
        """
        Creates a task to fetch file content using the GitHub API.

        Parameters:
            agent (Agent): The agent responsible for performing the task.
            owner (str): The owner of the repository.
            repo (str): The name of the repository.
            path (str): The file path.

        Returns:
            Task: Configured task for fetching file content.
        """
        try:
            return Task(
                agent=agent,
                description=f"""
                    You are given a file path and you have to get the content of the file and file name using the GitHub API.

                    Here is the file path:

                    {path}

                    Here is the owner name:

                    {owner}

                    Here is the repo name:

                    {repo}

                    Don't return anything except the filename and content.
                """,
                expected_output="filename and content of the given file"
            )
        except Exception as e:
            logging.error(f"Error creating content task: {e}")
            return None
```




# src/tools.py



my best complete final answer to the task.


# Project Name: code_challenge_reviewer

## Path: src/tools.py

## Explain This
This script defines a `Tools` class that contains a static method `get_file_contents`. This method fetches the contents of a file from a GitHub repository using the GitHub API. It requires the file path, owner of the repository, and the repository name as inputs. The script uses an environment variable `GITHUB_KEY` for authentication. It also checks the file size and the number of lines against configurable limits before returning the contents.

## Code Review
### Code Quality
- The code is generally well-organized and uses descriptive variable names.
- Docstrings are provided for the `get_file_contents` method, which enhances readability and maintainability.

### Bugs
- No explicit bugs were found, but there are areas for improvement in error handling and input validation.

### Anti-Patterns
- **Hardcoding API URL Check**: The check for `path.startswith("https://")` could be more robust. Instead, consider validating the URL format more comprehensively.
- **Static Configuration Limits**: The size and line count limits are set as static variables. It might be better to make them instance variables or configuration parameters that can be passed to the method.
- **Broad Exception Handling**: Catching a general `Exception` can mask other unexpected issues. It's better to handle specific exceptions.

### Improvements
1. **Environment Variable Check**: Move the environment variable check inside the method to avoid potential issues when the class is imported but not used.
2. **Error Handling**: Improve the granularity of exception handling to cover other possible exceptions like `JSONDecodeError`.
3. **Input Validation**: Validate inputs to ensure they meet expected formats and types.
4. **Logging**: Implement logging instead of returning error messages directly. This will help in debugging without exposing internal error details.
5. **Code Modularity**: Break down the `get_file_contents` method into smaller helper methods for better readability and testability.

### Compliance
- The script adheres to PEP 8 standards but can benefit from additional compliance checks, such as ensuring all imported modules are used and adding type hints for method parameters and return types.

## Updated Code
```python
import os
import requests
import base64
import logging
from langchain_community.tools import tool

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Tools():
    @staticmethod
    @tool("get file contents from given file path")
    def get_file_contents(path: str, owner: str, repo: str) -> str:
        """
        Fetches the content of a given file from GitHub using the provided path, owner, and repository name.

        Parameters:
            path (str): The file path or URL.
            owner (str): The owner of the repository.
            repo (str): The name of the repository.

        Returns:
            str: The content of the file or an error message.
        """
        # Ensure environment variable is set for GITHUB_KEY
        GITHUB_KEY = os.getenv('GITHUB_KEY')
        if not GITHUB_KEY:
            logger.error("GITHUB_KEY environment variable not set")
            return "Error: GITHUB_KEY environment variable not set"

        # Configurable thresholds
        MAX_FILE_SIZE = int(os.getenv('MAX_FILE_SIZE', 1000000))  # 1 MB
        MAX_LINE_COUNT = int(os.getenv('MAX_LINE_COUNT', 500))  # 500 lines

        if not path or not owner or not repo:
            logger.error("Invalid input parameters")
            return "Error: Invalid input parameters"

        # Construct the API URL
        if path.startswith("https://"):
            api_url = path
        else:
            api_url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"

        headers = {
            'Authorization': f'token {GITHUB_KEY}',
            'X-GitHub-Api-Version': '2022-11-28'
        }

        try:
            response = requests.get(api_url, headers=headers)
            response.raise_for_status()  # Raise an HTTPError for bad responses

            file_content = response.json()

            # Check the size of the file
            if file_content['size'] > MAX_FILE_SIZE:
                logger.warning("File size is greater than the configured limit")
                return "Skipped: File size is greater than the configured limit."

            # Decode the Base64 encoded content
            content_decoded = base64.b64decode(file_content['content'])

            # Convert bytes to string
            content_str = content_decoded.decode('utf-8')

            # Check the number of lines in the file
            if len(content_str.split('\n')) > MAX_LINE_COUNT:
                logger.warning("File contains more lines than the configured limit")
                return "Skipped: File contains more lines than the configured limit."

            return content_str

        except requests.exceptions.RequestException as e:
            logger.error(f"RequestException: {str(e)}")
            return f"Error: {str(e)}"
        except KeyError:
            logger.error("Unexpected response structure from GitHub API")
            return "Error: Unexpected response structure from GitHub API"
        except base64.binascii.Error as e:
            logger.error(f"Base64 decoding failed: {str(e)}")
            return f"Error: Base64 decoding failed - {str(e)}"
        except Exception as e:
            logger.error(f"An unexpected error occurred: {str(e)}")
            return f"Error: An unexpected error occurred - {str(e)}"
```


