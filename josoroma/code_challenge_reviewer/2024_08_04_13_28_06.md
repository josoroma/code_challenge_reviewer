

# src/agents.py



my best complete final answer to the task.

## Project Name: code_challenge_reviewer.

## Path: src/agents.py.

## Explain This:
The provided code defines a Python module that contains classes for creating and managing agents to perform specific tasks like code reviews, file path extraction, and fetching file content from GitHub. It also includes a class to handle stream output and display it in a Streamlit application.

The `Agents` class defines three types of agents:
1. `review_agent`: Configured to perform code reviews.
2. `path_agent`: Configured to extract file paths.
3. `content_agent`: Configured to fetch file content using the GitHub API.

The `StreamToExpander` class is designed to handle the output stream and display it in a Streamlit expander, filtering out ANSI escape codes and showing task-related information as a toast notification.

## Code Review:
### Code Quality:
- The code is well-structured and organized into classes with clearly defined roles.
- Docstrings are provided for classes and methods, which enhances readability and maintainability.
- Logging is used to capture exceptions, which is a good practice for debugging and monitoring.

### Bugs:
- There are no apparent bugs in the given code. However, the logging level is set to `ERROR`, which might miss out on important `INFO` or `WARNING` messages.

### Anti-Patterns:
- The `try-except` blocks are very generic. While they catch exceptions, they do not provide specific error messages that could help in debugging the exact issue.
- The `StreamToExpander` class has some redundant code for extracting task information which could be optimized.

### Improvements:
- Instead of using generic `Exception` handling, specific exceptions should be caught to make debugging easier.
- The list of colors in `StreamToExpander` is defined but not used. It should either be removed or utilized.
- The `verbose` parameter in the `Agent` initialization is set to `True` for all agents. It might be useful to make this configurable.
- The `st.toast` method is used but not imported from `streamlit`. Ensure all dependencies are correctly imported.
- The `tools` parameter in `content_agent` should be evaluated to ensure `Tools.get_file_contents` is a valid callable.

### Compliance:
- The code adheres to PEP 8 standards for naming conventions and structure.
- Proper use of logging and exception handling complies with best practices, although it can be improved as mentioned.

## Updated Code:
```python
import re
import logging
from crewai import Agent
import streamlit as st
from tools import Tools

# Set up logging configuration
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

class Agents:
    """
    Class to create and manage different types of agents.
    """

    REVIEW_AGENT_ROLE = 'Senior Software Developer'
    REVIEW_AGENT_GOAL = 'Perform detailed code reviews on the provided file to ensure it adheres to industry code quality standards. The code review should focus on the following aspects: evaluate code quality, identify bugs, spot anti-patterns, recommend improvements and ensure compliance.'
    REVIEW_AGENT_BACKSTORY = "You are a Senior Software Developer at a leading tech company, responsible for maintaining high code quality standards across the organization. As part of your role, you are tasked with conducting thorough code reviews on given file contents. Your goal is to ensure the code meets industry standards and follows best practices specific to the technologies in use."

    PATH_AGENT_ROLE = "File Path Extractor"
    PATH_AGENT_GOAL = "Get the tree structure of folder and return full paths of the given file or files of given folder in array format"
    PATH_AGENT_BACKSTORY = "You're a file path extractor who has created several file paths from given tree structures"

    CONTENT_AGENT_ROLE = "GitHub API Expert"
    CONTENT_AGENT_GOAL = "Get the content of given file using GitHub API"
    CONTENT_AGENT_BACKSTORY = "You're a GitHub API expert who has extracted many file contents using GitHub's API"

    def review_agent(self):
        """
        Creates a review agent for code reviews.

        Returns:
            Agent: Configured agent for performing code reviews.
        """
        try:
            return Agent(
                role=self.REVIEW_AGENT_ROLE,
                goal=self.REVIEW_AGENT_GOAL,
                backstory=self.REVIEW_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except (ValueError, TypeError) as e:
            logging.error("Error creating review agent: %s", e, exc_info=True)
            return None

    def path_agent(self):
        """
        Creates a path agent for extracting file paths.

        Returns:
            Agent: Configured agent for extracting file paths.
        """
        try:
            return Agent(
                role=self.PATH_AGENT_ROLE,
                goal=self.PATH_AGENT_GOAL,
                backstory=self.PATH_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except (ValueError, TypeError) as e:
            logging.error("Error creating path agent: %s", e, exc_info=True)
            return None

    def content_agent(self):
        """
        Creates a content agent for fetching file content using GitHub API.

        Returns:
            Agent: Configured agent for fetching file content using GitHub API.
        """
        try:
            return Agent(
                role=self.CONTENT_AGENT_ROLE,
                goal=self.CONTENT_AGENT_GOAL,
                backstory=self.CONTENT_AGENT_BACKSTORY,
                verbose=True,
                allow_delegation=False,
                tools=[Tools.get_file_contents],
            )
        except (ValueError, TypeError) as e:
            logging.error("Error creating content agent: %s", e, exc_info=True)
            return None

class StreamToExpander:
    def __init__(self, expander):
        self.expander = expander
        self.buffer = []

    def write(self, data):
        # Filter out ANSI escape codes using a regular expression
        cleaned_data = re.sub(r'\x1B\[[0-9;]*[mK]', '', data)

        # Extract task information
        task_match = re.search(r'\"?task\"?\s*:\s*\"?([^\"]*)\"?', cleaned_data, re.IGNORECASE)

        if task_match:
            task_value = task_match.group(1).strip()
            st.toast(":robot_face: " + task_value)

        self.buffer.append(cleaned_data)

        if "\n" in data:
            self.expander.code(''.join(self.buffer), language='bash')
            self.buffer = []

    def clear_buffer(self):
        """Clears the buffer to free memory."""
        self.buffer = []
```

This updated code includes more specific exception handling, removes unused variables, and ensures that all dependencies are correctly imported.



# src/constants.py



## Project Name: code_challenge_reviewer

## Path: src/constants.py

## Explain This:
This file, `constants.py`, contains several constants that are used in the `code_challenge_reviewer` project. These constants include URLs, file paths, and directory structures related to the application's repository. Specifically, it defines the repository URL, paths to specific files within the repository, and an example of the repository's structure in a string format.

## Code Review:
### Code Quality:
1. **Redundancy**:
    - The constant `APP_REPO_PATH` is defined twice with the same value, which is unnecessary and could lead to confusion.
    
2. **Readability**:
    - The multi-line string for `APP_REPO_STRUCTURE` is useful for visualizing the directory structure but could be more structured as a list of strings for easier manipulation.

### Bugs:
- No explicit bugs are present, but the redundancy of `APP_REPO_PATH` could potentially lead to maintenance issues.

### Anti-Patterns:
- Re-declaration of the constant `APP_REPO_PATH` is an anti-pattern as it introduces redundancy and potential confusion.

### Improvements:
1. **Remove Redundancy**:
    - Define `APP_REPO_PATH` only once.
    
2. **Use Lists for Structure**:
    - Change the multi-line string `APP_REPO_STRUCTURE` to a list for better structure and manipulation.

3. **Compliance**:
   - The code generally complies with Python standards, but improvements can make it cleaner and more maintainable.

### Updated Code:
```python
APP_REPO_URL = "https://github.com/josoroma/code_challenge_reviewer"

APP_REPO_PATH = "src/agents.py"

APP_REPO_STRUCTURE = [
    "src",
    "  - agents.py",
    "  - main.py",
    "  - tools.py"
]

APP_REPO_FILE_SAMPLE = "agents.py"
APP_REPO_FULLPATH_SAMPLE = "src/agents.py"

APP_REPO_OUTPUT = "['src/agents.py', 'src/main.py', 'tools.py']"
```

By making these changes, the code becomes more concise, readable, and maintainable. The list format for `APP_REPO_STRUCTURE` makes it easier to manage and understand the repository's structure.



# src/github_helper.py



## Project Name: code_challenge_reviewer

## Path: src/github_helper.py

## Explain This:
The `github_helper.py` file is designed to fetch and display the directory tree structure of a GitHub repository. It uses the GitHub API to retrieve repository contents and displays them in a hierarchical format. The script uses environment variables, logging, and handles various exceptions that may occur during API requests. It specifically avoids certain directories like 'public', 'images', 'media', and 'assets'.

## Code Review:
### Code Quality:
- The code is well-structured and modular, with a clear separation of concerns.
- Functions are well-defined with appropriate parameters and return types.
- The use of logging is good for debugging and tracking errors.
- The code includes comprehensive docstrings, enhancing readability and maintainability.

### Bugs:
- No significant bugs identified, but the code can be optimized for better performance and readability.

### Anti-Patterns:
- The use of recursion without a clear base case or exit condition could lead to potential stack overflow issues for very deep repository structures.
- The use of string concatenation for building the output could be replaced with a more efficient approach.

### Improvements:
- Use a list to accumulate lines of output and join them at the end for better performance.
- Add type hints for better clarity.
- Improve exception handling by logging the specific error message and re-raising critical exceptions.
- Add a base case for the recursion to avoid potential infinite loops.
- Ensure compliance with PEP 8 standards.

## Updated Code:
```python
import os
import requests
import streamlit as st
import logging
from typing import List

# Set up logging
logging.basicConfig(level=logging.INFO)

# Ensure environment variable is set for GITHUB_KEY
GITHUB_KEY = os.getenv('GITHUB_KEY')
if not GITHUB_KEY:
    logging.error("GITHUB_KEY environment variable not set.")
    raise ValueError("GITHUB_KEY environment variable not set.")

def get_file_tree(owner: str, repo: str, path: str = "", level: int = 0, max_depth: int = 10) -> str:
    """
    Fetch and print the tree structure of a GitHub repository, ignoring specific folders.

    Parameters:
    - owner: The username of the repository owner.
    - repo: The name of the repository.
    - path: The path to fetch. Leave empty to fetch the root directory.
    - level: The current depth in the tree structure.
    - max_depth: The maximum depth to recurse into directories.

    Returns:
    - str: The tree structure as a string.
    """
    # Directories to ignore
    ignore_dirs = {'public', 'images', 'media', 'assets'}

    if level > max_depth:
        return ""

    api_url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"
    headers = {'Authorization': f'token {GITHUB_KEY}'}

    output_lines: List[str] = []

    try:
        # Make the request
        response = requests.get(api_url, headers=headers, verify=True)
        response.raise_for_status()
        items = response.json()

        if isinstance(items, list):
            for item in items:
                # Skip ignored directories
                if item['name'] in ignore_dirs:
                    continue

                item_name = f"{' ' * (level * 2)}- {item['name']}"
                output_lines.append(item_name)

                if item['type'] == 'dir':
                    sub_tree = get_file_tree(owner, repo, item['path'], level + 1, max_depth)
                    output_lines.append(sub_tree)

        return "\n".join(output_lines)

    except requests.exceptions.HTTPError as http_err:
        logging.error(f"HTTP error occurred: {http_err}")
        return ""
    except requests.exceptions.ConnectionError as conn_err:
        logging.error(f"Connection error occurred: {conn_err}")
        return ""
    except requests.exceptions.Timeout as timeout_err:
        logging.error(f"Timeout error occurred: {timeout_err}")
        return ""
    except requests.exceptions.RequestException as req_err:
        logging.error(f"Request error: {req_err}")
        return ""
    except ValueError:
        logging.error("Error: Unable to parse the response from GitHub.")
        return ""
    except Exception as e:
        logging.error(f"Unexpected error occurred: {str(e)}")
        return ""

```

This updated code optimizes performance, enhances clarity, and ensures better compliance with industry standards.



# src/review_crew.py



my best complete final answer to the task.

```markdown
## Project Name: code_challenge_reviewer.

## Path: src/review_crew.py.

## Explain This:
This script defines a `ReviewCrew` class to handle the review process for a given file in a GitHub repository. It initializes with repository details and outputs the review results in a markdown file. The script uses `streamlit` for displaying output, and `logging` for logging errors. It integrates with external modules `Agents`, `Tasks`, and `Crew` to perform the review tasks and manage agents. The `run` method executes the review process and logs results.

## Code Review:
### Code Quality
- Overall, the code is well-structured and adheres to PEP8 standards.
- The use of docstrings for methods and classes is commendable.
- The logging setup is robust and will be helpful in debugging issues.

### Bugs
- No apparent bugs in the code, but exception handling can be improved for better clarity and troubleshooting.

### Anti-Patterns
- The use of `try-except` blocks can be more specific to handle different types of exceptions separately.
- The instantiation of `Agents` and `Tasks` in the `run` method can be moved to the constructor for better initialization practices.

### Improvements
- Add type hints for method parameters and return types for better readability and maintenance.
- Improve exception handling by catching specific exceptions rather than a broad `Exception`.
- Consider adding unit tests to validate the functionality of each method.

### Compliance
- The code adheres to industry standards, but adding type hints and more specific exception handling will make it more robust.

## Updated Code:

```python
import os
import re
import streamlit as st
import logging
from crewai import Crew
from agents import Agents
from tasks import Tasks
from typing import Optional

# Create a custom logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# Create handlers
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)

# Create formatters and add them to the handlers
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)

# Add handlers to the logger
logger.addHandler(console_handler)

class ReviewCrew:
    """
    Class to handle the review process for a given file in a GitHub repository.
    """

    def __init__(self, owner: str, repo: str, path: str, output: str) -> None:
        """
        Initializes the ReviewCrew with the repository details.

        Parameters:
            owner (str): The owner of the repository.
            repo (str): The name of the repository.
            path (str): The path of the file to review.
            output (str): The path of the single file with all the repo files reviewed.
        """
        self.owner = owner
        self.repo = repo
        self.path = path
        self.output = output
        self.output_placeholder = st.empty()
        self.agents = Agents()
        self.tasks = Tasks()

    def append_review_to_file(self, result: str) -> None:
        """
        Appends the explain and the review result to a markdown file.

        Parameters:
            result (str): The str containing the explain and the review results in markdown format.
        """
        # Create directory path using owner and repo
        dir_path = os.path.join(self.owner, self.repo)
        os.makedirs(dir_path, exist_ok=True)

        # Create a file with the current date as its name
        file_path = os.path.join(dir_path, self.output)

        try:
            with open(file_path, 'a') as file:
                file.write(f"\n\n# {self.repo} - {self.path}\n\n")
                file.write(result)
        except OSError as e:
            logger.error(f"OS error writing to file: {e}")
        except Exception as e:
            logger.error(f"Unexpected error writing to file: {e}")

    def run(self) -> Optional[str]:
        """
        Runs the review process using the defined agents and tasks.
        """
        try:
            # The Agents
            review_agent = self.agents.review_agent()
            content_agent = self.agents.content_agent()

            # The Tasks
            content_task = self.tasks.content_task(
                agent=content_agent,
                owner=self.owner,
                repo=self.repo,
                path=self.path
            )
            review_task = self.tasks.review_task(
                agent=review_agent,
                repo=self.repo,
                path=self.path,
                context=[content_task]
            )

            # The Crew
            crew = Crew(
                agents=[content_agent, review_agent],
                tasks=[content_task, review_task],
                verbose=2,
                telemetry=False
            )

            # Run the crew
            kickoff_result = crew.kickoff()

            str_result = str(kickoff_result).strip()

            result = re.sub(r'^```markdown|```$', '', str_result, flags=re.DOTALL)

            self.append_review_to_file(f"\n\n{result}\n\n")

            self.output_placeholder.code(f"\n\n{result}\n\n", language='markdown')

            return result

        except OSError as e:
            logger.error(f"OS error running ReviewCrew: {e}")
        except Exception as e:
            logger.error(f"Unexpected error running ReviewCrew: {e}")
            return None
```




# src/tasks.py



## Project Name
code_challenge_reviewer

## Path
src/tasks.py

## Explain This
The `Tasks` class is responsible for creating and managing different types of tasks using the `crewai` library. It has three methods: `review_task`, `get_file_path_task`, and `content_task`. Each method is designed to create a specific type of task. The `review_task` method sets up a task for code review, `get_file_path_task` determines file paths from a directory tree structure, and the `content_task` fetches the content of a file from a GitHub repository.

## Code Review

### Code Quality
- The code is generally well-structured and uses meaningful variable names.
- Docstrings are provided for all methods, which is good for understanding the functionality.
- However, there are a few improvements that can be made to enhance readability and maintainability.

### Bugs
- No apparent bugs were found in the logic of the code. But logging can be improved for better debugging.

### Anti-Patterns
- The methods catch exceptions and log an error but still return `None`. This could lead to silent failures. It might be better to either raise the exception or handle it in a way that informs the calling function.

### Improvements
- Add type hints for method return values.
- Refactor the `description` string to use triple single quotes to avoid confusion with double quotes inside the string.
- Improve logging to include more context, such as which method failed.
- Consider raising exceptions after logging them to avoid silent failures.

### Compliance
- The code follows PEP 8 standards for the most part but can improve by adding type hints and better exception handling.

## Updated Code
```python
from crewai import Task
import logging
from crewai import Agent

class Tasks:
    """
    Class to create and manage different types of tasks.
    """

    def review_task(self, agent: Agent, repo: str, path: str, context: str) -> Task:
        """
        Creates a review task for a given file.

        Parameters:
            agent (Agent): The agent responsible for performing the review.
            repo (str): The name of the repository.
            path (str): The file path.
            context (str): The context for the task.

        Returns:
            Task: Configured task for performing the review.
        """
        try:
            return Task(
                agent=agent,
                description=f'''
                    Review the given file and provide detailed feedback and a code review to ensure it adheres to industry code quality standards.

                    - Take the file path and file contents from `content_agent`.
                    - Provide a detailed code review with feedback on the following aspects:
                       * Code Quality
                       * Bugs
                       * Anti-Patterns
                       * Improvements
                       * Compliance
                    - Make necessary improvements to the file content and return the updated content as `updated_code`.

                    Return the following values in the markdown content output:

                    - Project Name: {repo}.
                    - Path: {path}.
                    - Explain This: generate documentation for this code, explain the entire code in a few lines.
                    - Code Review: detailed explain the code review for this code, provide feedback on the code quality, bugs, anti-patterns, improvements, and compliance.
                    - Updated Code: updated code of file after making code review and changes.

                    The attributes returned must be in markdown format, as heading h2 or ## and the value as its nested text.

                    The `Updated Code` output string must be a string in python format. This `Updated Code` output string should be involved by backticks such as ```python updated_code_output ```.

                    Only return the explained and reviewed file content. If there are multiple explains and reviews, return the entire reviewed file content in markdown format.

                    Task output must be a string in markdown format and ensure the markdown content is accurate and well-structured.
                ''',
                context=context,
                expected_output="Only return the string output in markdown format and ensure the markdown content is accurate and well-structured."
            )
        except Exception as e:
            logging.error(f"Error creating review task: {e}, repo: {repo}, path: {path}")
            raise

    def get_file_path_task(self, agent: Agent, file_tree: str, repo_directory: str, repo_structure: str, repo_file_sample: str, repo_fullpath_sample: str, repo_output_sample: str) -> Task:
        """
        Creates a task to get the file path from a given tree structure.

        Parameters:
            agent (Agent): The agent responsible for performing the task.
            file_tree (str): The tree structure of the folder.
            repo_directory (str): The user input (file or folder name).

        Returns:
            Task: Configured task for extracting file paths.
        """
        try:
            return Task(
                agent=agent,
                description=f'''
                    You are given a tree structure of folder and repo_directory. First, you have to decide whether it is a folder or file from the given tree structure of a folder.

                    Follow this approach:

                    - If it's a file then return array with 1 element which contains the full path of that file in this folder structure.
                    - If it's a folder then return array of paths of sub files inside that folder. If there is a subfolder in given folder, then return paths for those files as well.
                    - If repo_directory is not present in given tree structure then just return an empty array.

                    Please return the FULL path of a given file in the given folder tree structure. For example, if the tree structure looks like this:

                    {repo_structure}

                    Then the full path of {repo_file_sample} will be "{repo_fullpath_sample}".

                    DON'T send every file content at once, send it one by one to review_agent.

                    Here is the tree structure of the folder:

                    {file_tree}

                    Here is user input:

                    {repo_directory}

                    NOTE: ONLY RETURN ARRAY OF PATHS WITHOUT ANY EXTRA TEXT IN RESPONSE.
                ''',
                expected_output=f'''
                    ONLY an array of paths.
                    For example:
                    {repo_output_sample}
                '''
            )
        except Exception as e:
            logging.error(f"Error creating file path task: {e}, repo_directory: {repo_directory}")
            raise

    def content_task(self, agent: Agent, owner: str, repo: str, path: str) -> Task:
        """
        Creates a task to fetch file content using the GitHub API.

        Parameters:
            agent (Agent): The agent responsible for performing the task.
            owner (str): The owner of the repository.
            repo (str): The name of the repository.
            path (str): The file path.

        Returns:
            Task: Configured task for fetching file content.
        """
        try:
            return Task(
                agent=agent,
                description=f'''
                    You are given a file path and you have to get the content of the file and file name using the GitHub API.

                    Here is the file path:

                    {path}

                    Here is the owner name:

                    {owner}

                    Here is the repo name:

                    {repo}

                    Don't return anything except the filename and content.
                ''',
                expected_output="filename and content of the given file"
            )
        except Exception as e:
            logging.error(f"Error creating content task: {e}, owner: {owner}, repo: {repo}, path: {path}")
            raise




# src/tools.py



my best complete final answer to the task.

```markdown
## Project Name: code_challenge_reviewer.
## Path: src/tools.py.
## Explain This:
This script is designed to fetch the content of a file from a GitHub repository. It ensures that the `GITHUB_KEY` environment variable is set for authorization. The script defines a class `Tools` with a static method `get_file_contents` that takes the file path, repo owner, and repo name as parameters. It fetches the file content using GitHub API and performs checks on the file size and line count before returning the file content.

## Code Review:
### Code Quality:
- The code is generally well-structured and modular.
- The use of environment variables for configuration is a good practice.

### Bugs:
- No obvious bugs are present in the code.

### Anti-Patterns:
- The method `get_file_contents` is decorated with `@tool` but the decorator's functionality is not clear from the provided context.
- The method does not handle the case where the file size or line count exceeds the limit beyond returning a string message. Ideally, it should raise an exception or return a structured response indicating the error.

### Improvements:
- Add type hints to function parameters and return types for better readability and type checking.
- Use constants for API versions and error messages to avoid hardcoding strings.
- Add logging for better traceability and debugging.
- Split the method into smaller functions to improve readability and maintainability.
- Use context managers for managing requests to ensure resources are properly released.

### Compliance:
- The code adheres to PEP 8 standards, but adding type hints would enhance compliance with modern Python practices.

## Updated Code:
```python
import os
import requests
import base64
from langchain_community.tools import tool

# Ensure environment variable is set for GITHUB_KEY
GITHUB_KEY = os.getenv('GITHUB_KEY')
if not GITHUB_KEY:
    raise EnvironmentError("GITHUB_KEY environment variable not set")

# Configurable thresholds
MAX_FILE_SIZE = int(os.getenv('MAX_FILE_SIZE', 1000000))  # 1 MB
MAX_LINE_COUNT = int(os.getenv('MAX_LINE_COUNT', 500))  # 500 lines

# Constants for the GitHub API
GITHUB_API_VERSION = '2022-11-28'
ERROR_UNEXPECTED_STRUCTURE = "Error: Unexpected response structure from GitHub API"
ERROR_BASE64_DECODING = "Error: Base64 decoding failed"
ERROR_UNEXPECTED = "Error: An unexpected error occurred"

class Tools:
    @staticmethod
    @tool("get file contents from given file path")
    def get_file_contents(path: str, owner: str, repo: str) -> str:
        """
        Fetches the content of a given file from GitHub using the provided path, owner, and repository name.

        Parameters:
            path (str): The file path or URL.
            owner (str): The owner of the repository.
            repo (str): The name of the repository.

        Returns:
            str: The content of the file or an error message.
        """
        api_url = Tools._construct_api_url(path, owner, repo)
        headers = Tools._construct_headers()

        try:
            response = requests.get(api_url, headers=headers)
            response.raise_for_status()
            file_content = response.json()
            content_str = Tools._handle_file_content(file_content)
            return content_str
        except requests.exceptions.RequestException as e:
            return f"Error: {str(e)}"
        except KeyError:
            return ERROR_UNEXPECTED_STRUCTURE
        except base64.binascii.Error as e:
            return f"{ERROR_BASE64_DECODING} - {str(e)}"
        except Exception as e:
            return f"{ERROR_UNEXPECTED} - {str(e)}"

    @staticmethod
    def _construct_api_url(path: str, owner: str, repo: str) -> str:
        if path.startswith("https://"):
            return path
        return f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"

    @staticmethod
    def _construct_headers() -> dict:
        return {
            'Authorization': f'token {GITHUB_KEY}',
            'X-GitHub-Api-Version': GITHUB_API_VERSION
        }

    @staticmethod
    def _handle_file_content(file_content: dict) -> str:
        if file_content['size'] > MAX_FILE_SIZE:
            return "Skipped: File size is greater than the configured limit."
        content_decoded = base64.b64decode(file_content['content'])
        content_str = content_decoded.decode('utf-8')
        if len(content_str.split('\n')) > MAX_LINE_COUNT:
            return "Skipped: File contains more lines than the configured limit."
        return content_str
```


