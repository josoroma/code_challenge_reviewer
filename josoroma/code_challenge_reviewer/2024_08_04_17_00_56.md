

# src/agents.py



my best complete final answer to the task.


## Project Name: code_challenge_reviewer

## Path: src/agents.py

## Explain This:
This module defines two classes, `Agents` and `StreamToExpander`. 

The `Agents` class is responsible for creating different types of agents for various tasks such as code reviews, extracting file paths, and fetching file contents using the GitHub API. Each agent is configured with specific roles, goals, and backstories. The class methods `review_agent`, `path_agent`, and `content_agent` each return a configured agent for their respective tasks.

The `StreamToExpander` class is a utility that streams data to a Streamlit expander element. It filters out ANSI escape codes from the data and checks for 'task' information to display as notifications. The class also buffers the data and displays it within the expander once a newline character is detected.

## Code Review:
### Code Quality:
- The code is generally well-structured and follows PEP 8 guidelines.
- Docstrings are provided for methods, which is good for readability and maintenance.
- The use of constants for agent roles, goals, and backstories improves readability and maintainability.

### Bugs:
- The `write` method in `StreamToExpander` might not handle large chunks of data efficiently due to continuous appending to the buffer and frequent UI updates.

### Anti-Patterns:
- The `try-except` blocks in the `Agents` class methods are too broad. They catch all exceptions, which can hide different types of errors.
- Hardcoding color values and indices in `StreamToExpander` is not flexible for future changes.

### Improvements:
- Use more specific exception handling to catch only expected exceptions.
- Consider using a configuration file or environment variables for agent roles, goals, and backstories.
- Optimize the `write` method to handle large data more efficiently, possibly by buffering data and updating the UI less frequently.
- Use logging levels appropriately to differentiate between error types.
- Avoid hardcoding by externalizing color configurations.

### Compliance:
- The code complies with standard Python coding practices and PEP 8 guidelines.
- Logging is set up correctly, although the use of different logging levels can be improved.

## Updated Code:
```python
import re
import logging
from crewai import Agent
import streamlit as st
from tools import Tools

# Set up logging configuration
logging.basicConfig(level=logging.ERROR, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

class Agents:
    """
    Class to create and manage different types of agents.
    """

    REVIEW_AGENT_ROLE = 'Senior Software Developer'
    REVIEW_AGENT_GOAL = 'Perform detailed code reviews on the provided file to ensure it adheres to industry code quality standards. The code review should focus on the following aspects: evaluate code quality, identify bugs, spot anti-patterns, recommend improvements and ensure compliance.'
    REVIEW_AGENT_BACKSTORY = "You are a Senior Software Developer at a leading tech company, responsible for maintaining high code quality standards across the organization. As part of your role, you are tasked with conducting thorough code reviews on given file contents. Your goal is to ensure the code meets industry standards and follows best practices specific to the technologies in use."

    PATH_AGENT_ROLE = "File Path Extractor"
    PATH_AGENT_GOAL = "Get the tree structure of folder and return full paths of the given file or files of given folder in array format"
    PATH_AGENT_BACKSTORY = "You're a file path extractor who has created several file paths from given tree structures"

    CONTENT_AGENT_ROLE = "GitHub API Expert"
    CONTENT_AGENT_GOAL = "Get the content of given file using GitHub API"
    CONTENT_AGENT_BACKSTORY = "You're a GitHub API expert who has extracted many file contents using GitHub's API"

    def review_agent(self):
        """
        Creates a review agent for code reviews.

        Returns:
            Agent: Configured agent for performing code reviews.
        """
        try:
            return Agent(
                role=self.REVIEW_AGENT_ROLE,
                goal=self.REVIEW_AGENT_GOAL,
                backstory=self.REVIEW_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except (ConnectionError, TimeoutError) as e:
            logging.error("Network-related error creating review agent", exc_info=True)
            return None
        except Exception as e:
            logging.error("Unexpected error creating review agent", exc_info=True)
            return None

    def path_agent(self):
        """
        Creates a path agent for extracting file paths.

        Returns:
            Agent: Configured agent for extracting file paths.
        """
        try:
            return Agent(
                role=self.PATH_AGENT_ROLE,
                goal=self.PATH_AGENT_GOAL,
                backstory=self.PATH_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except (ConnectionError, TimeoutError) as e:
            logging.error("Network-related error creating path agent", exc_info=True)
            return None
        except Exception as e:
            logging.error("Unexpected error creating path agent", exc_info=True)
            return None

    def content_agent(self):
        """
        Creates a content agent for fetching file content using GitHub API.

        Returns:
            Agent: Configured agent for fetching file content using GitHub API.
        """
        try:
            return Agent(
                role=self.CONTENT_AGENT_ROLE,
                goal=self.CONTENT_AGENT_GOAL,
                backstory=self.CONTENT_AGENT_BACKSTORY,
                verbose=True,
                allow_delegation=False,
                tools=[Tools.get_file_contents],
            )
        except (ConnectionError, TimeoutError) as e:
            logging.error("Network-related error creating content agent", exc_info=True)
            return None
        except Exception as e:
            logging.error("Unexpected error creating content agent", exc_info=True)
            return None

class StreamToExpander:
    def __init__(self, expander, colors=None):
        self.expander = expander
        self.buffer = []
        self.colors = colors or ['red', 'green', 'blue', 'orange']  # Use provided colors or default
        self.color_index = 0  # Initialize color index

    def write(self, data):
        # Filter out ANSI escape codes using a regular expression
        cleaned_data = re.sub(r'\x1B\[[0-9;]*[mK]', '', data)

        # Check if the data contains 'task' information
        task_match_object = re.search(r'\"task\"\s*:\s*\"(.*?)\"', cleaned_data, re.IGNORECASE)
        task_match_input = re.search(r'task\s*:\s*([^\n]*)', cleaned_data, re.IGNORECASE)

        task_value = None

        if task_match_object:
            task_value = task_match_object.group(1)
        elif task_match_input:
            task_value = task_match_input.group(1).strip()

        if task_value:
            st.toast(":robot_face: " + task_value)

        self.buffer.append(cleaned_data)
        
        # Efficient data handling
        if "\n" in data:
            self.expander.code(''.join(self.buffer), language='bash')
            self.buffer = []

    def clear_buffer(self):
        """Clears the buffer to free memory."""
        self.buffer = []
```




# src/constants.py



my best complete final answer to the task.


## Project Name: code_challenge_reviewer

## Path: src/constants.py

## Explain This
This file defines several constants related to the project repository. These constants include the repository URL, paths to specific files within the repository, and the structure of the repository. The constants are used throughout the project to maintain consistency and avoid hard-coding these values in multiple places.

## Code Review
### Code Quality
- The constants are defined using uppercase letters, which is a good practice for defining constants.
- The values are directly assigned without any computation, which is appropriate for constants.

### Bugs
- There are duplicate definitions for `APP_REPO_PATH`, which can lead to confusion and potential bugs if the values are not consistent.

### Anti-Patterns
- Redundant constants: `APP_REPO_FILE_SAMPLE` and `APP_REPO_FULLPATH_SAMPLE` seem to represent similar information. They can be consolidated to avoid redundancy.
- Hardcoded structure: The repository structure is hardcoded as a multi-line string. This is acceptable but can be better represented using a data structure like a list for easier manipulation and validation.

### Improvements
- Remove duplicate definitions of `APP_REPO_PATH`.
- Consolidate `APP_REPO_FILE_SAMPLE` and `APP_REPO_FULLPATH_SAMPLE` into a single constant.
- Consider using a list to represent the repository structure for better flexibility and manipulation.

### Compliance
- The code generally follows standard Python practices for defining constants.

## Updated Code
```python
APP_REPO_URL = "https://github.com/josoroma/code_challenge_reviewer"

APP_REPO_PATH = "src/agents.py"

APP_REPO_STRUCTURE = [
    'src',
    'src/agents.py',
    'src/main.py',
    'src/tools.py'
]

APP_REPO_FILE_SAMPLE = "src/agents.py"

APP_REPO_OUTPUT = ['src/agents.py', 'src/main.py', 'tools.py']
```




# src/github_helper.py



my best complete final answer to the task.


## Project Name: code_challenge_reviewer

## Path: src/github_helper.py

## Explain This:
This script is a helper tool for interacting with the GitHub API to fetch and print the directory tree structure of a specified GitHub repository. The main function `get_file_tree` takes in the repository owner's username, the repository name, and an optional path, level, and maximum depth to control the depth of directory traversal. The script handles authentication via a GitHub API token stored in an environment variable and includes error handling for various types of HTTP and connection errors.

## Code Review:
### Code Quality:
- The code is generally well-structured and readable. The use of logging and environment variables for the GitHub token is appropriate.
- Docstrings are provided for the main function, making the parameters and return values clear.

### Bugs:
- No explicit bugs were found in the current code structure.

### Anti-Patterns:
- The function uses recursion without any mechanism to handle very deep directory structures, which could potentially lead to a stack overflow.
- The `ignore_dirs` set is defined inside the function, which is fine in this context but could be moved to a global constant if it does not change.

### Improvements:
- Add type hints to improve code readability and maintainability.
- Consider adding a mechanism to limit the number of recursive calls more robustly.
- Improve the error messages to provide more actionable information.
- Refactor the code to avoid global state by passing the `GITHUB_KEY` as a parameter to the function.
- Add unit tests to ensure the function works correctly.

### Compliance:
- The code adheres to PEP 8 standards for Python code.
- Appropriate error handling is included, ensuring the program does not crash on encountering common HTTP errors.

## Updated Code:
```python
import os
import requests
import streamlit as st
import logging
from typing import Optional

# Set up logging
logging.basicConfig(level=logging.INFO)

# Ensure environment variable is set for GITHUB_KEY
GITHUB_KEY = os.getenv('GITHUB_KEY')
if not GITHUB_KEY:
    logging.error("GITHUB_KEY environment variable not set.")
    raise ValueError("GITHUB_KEY environment variable not set.")

IGNORE_DIRS = {'public', 'images', 'media', 'assets'}

def get_file_tree(owner: str, repo: str, path: str = "", level: int = 0, max_depth: int = 10, token: Optional[str] = GITHUB_KEY) -> str:
    """
    Fetch and print the tree structure of a GitHub repository, ignoring specific folders.

    Parameters:
    - owner: The username of the repository owner.
    - repo: The name of the repository.
    - path: The path to fetch. Leave empty to fetch the root directory.
    - level: The current depth in the tree structure.
    - max_depth: The maximum depth to recurse into directories.
    - token: The GitHub API token for authentication.

    Returns:
    - str: The tree structure as a string.
    """
    if level > max_depth:
        return ""

    api_url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"
    headers = {'Authorization': f'token {token}'}

    output = ""

    try:
        # Make the request
        response = requests.get(api_url, headers=headers, verify=True)
        response.raise_for_status()
        items = response.json()

        if isinstance(items, list):
            for item in items:
                # Skip ignored directories
                if item['name'] in IGNORE_DIRS:
                    continue

                item_name = f"{' ' * (level * 2)}- {item['name']}"
                output += f"{item_name}\n"

                if item['type'] == 'dir':
                    output += get_file_tree(owner, repo, item['path'], level + 1, max_depth, token)

        return output

    except requests.exceptions.HTTPError as http_err:
        logging.error(f"HTTP error occurred: {http_err.response.status_code} {http_err.response.reason}")
        return ""
    except requests.exceptions.ConnectionError as conn_err:
        logging.error(f"Connection error occurred: {conn_err}")
        return ""
    except requests.exceptions.Timeout as timeout_err:
        logging.error(f"Timeout error occurred: {timeout_err}")
        return ""
    except requests.exceptions.RequestException as req_err:
        logging.error(f"Request error: {req_err}")
        return ""
    except ValueError:
        logging.error("Error: Unable to parse the response from GitHub.")
        return ""
    except Exception as e:
        logging.error(f"Unexpected error occurred: {str(e)}")
        return ""
```




# src/review_crew.py



my best complete final answer to the task.


## Project Name: code_challenge_reviewer
## Path: src/review_crew.py

## Explain This:
The `review_crew.py` script is designed to manage the review process for a specific file within a GitHub repository. It leverages the `streamlit` library for UI components and handles the review task using custom `Agents` and `Tasks`. The `ReviewCrew` class is initialized with repository details and supports appending review results to a markdown file. It also runs the review process using defined agents and tasks, and logs the results.

## Code Review:
### Code Quality:
- The code is generally well-structured and easy to follow.
- Proper use of logging for error handling and debugging.
- Docstrings are provided for classes and methods, enhancing readability and maintainability.

### Bugs:
- No apparent bugs found in the code.

### Anti-Patterns:
- The use of `try-except` blocks is good, but consider handling specific exceptions rather than a general `Exception` to ensure better error handling.
- The `run` method is quite long and could be broken down into smaller methods to enhance readability and maintainability.

### Improvements:
1. **Exception Handling**: Handle specific exceptions rather than using a general `Exception`.
2. **Method Decomposition**: Break down the `run` method into smaller, more manageable methods.
3. **Type Hints**: Add type hints to method signatures to improve code clarity and maintainability.
4. **Logging Improvements**: Add more context to log messages to make debugging easier.

### Compliance:
- The code follows PEP 8 standards for the most part.
- Logging is properly set up and used for error reporting.

## Updated Code:
```python
import os
import re
import streamlit as st
import logging
from crewai import Crew
from agents import Agents
from tasks import Tasks

# Create a custom logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# Create handlers
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)

# Create formatters and add them to the handlers
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)

# Add handlers to the logger
logger.addHandler(console_handler)


class ReviewCrew:
    """
    Class to handle the review process for a given file in a GitHub repository.
    """

    def __init__(self, owner: str, repo: str, path: str, output: str):
        """
        Initializes the ReviewCrew with the repository details.

        Parameters:
            owner (str): The owner of the repository.
            repo (str): The name of the repository.
            path (str): The path of the file to review.
            output (str): The path of the single file with all the repo files reviewed.
        """
        self.owner = owner
        self.repo = repo
        self.path = path
        self.output = output
        self.output_placeholder = st.empty()

    def append_review_to_file(self, result: str):
        """
        Appends the explain and the review result to a markdown file.

        Parameters:
            result (str): The str containing the explain and the review results in markdown format.
        """
        # Create directory path using owner and repo
        dir_path = os.path.join(self.owner, self.repo)
        os.makedirs(dir_path, exist_ok=True)

        # Create a file with the current date as its name
        file_path = os.path.join(dir_path, self.output)

        try:
            with open(file_path, 'a') as file:
                file.write(f"\n\n# {self.repo} - {self.path}\n\n")
                file.write(result)
        except OSError as e:
            logger.error(f"OS error: {e}")
        except IOError as e:
            logger.error(f"I/O error: {e}")
        except Exception as e:
            logger.error(f"Unexpected error: {e}")

    def run(self):
        """
        Runs the review process using the defined agents and tasks.
        """
        try:
            agents, tasks = self.setup_agents_and_tasks()
            crew = self.setup_crew(agents, tasks)
            result = self.execute_crew(crew)
            self.append_review_to_file(f"\n\n{result}\n\n")
            self.output_placeholder.code(f"\n\n{result}\n\n", language='markdown')
            return result
        except Exception as e:
            logger.error(f"Error running ReviewCrew: {e}")
    
    def setup_agents_and_tasks(self):
        """
        Initializes agents and tasks.

        Returns:
            tuple: A tuple containing the list of agents and tasks.
        """
        # The Agents
        agents = Agents()
        review_agent = agents.review_agent()
        content_agent = agents.content_agent()

        # The Tasks
        tasks = Tasks()
        content_task = tasks.content_task(
            agent=content_agent,
            owner=self.owner,
            repo=self.repo,
            path=self.path
        )
        review_task = tasks.review_task(
            agent=review_agent,
            repo=self.repo,
            path=self.path,
            context=[content_task]
        )

        return [content_agent, review_agent], [content_task, review_task]

    def setup_crew(self, agents: list, tasks: list):
        """
        Configures the Crew with agents and tasks.

        Parameters:
            agents (list): List of agents.
            tasks (list): List of tasks.

        Returns:
            Crew: An instance of the Crew class.
        """
        return Crew(
            agents=agents,
            tasks=tasks,
            verbose=2,
            telemetry=False
        )

    def execute_crew(self, crew: Crew):
        """
        Executes the Crew's kickoff method and processes the result.

        Parameters:
            crew (Crew): The Crew instance to be executed.

        Returns:
            str: The processed result as a string.
        """
        kickoff_result = crew.kickoff()
        str_result = str(kickoff_result).strip()
        return re.sub(r'^|```$', '', str_result, flags=re.DOTALL)
```




# src/tasks.py



my best complete final answer to the task.

 output
## Project Name: code_challenge_reviewer.
## Path: src/tasks.py.

## Explain This:
The code defines a `Tasks` class with methods to create and manage different types of tasks using the `crewai` library. It includes functionalities for creating review tasks, fetching file paths from a directory structure, and retrieving file content from GitHub.

1. **review_task**: This method creates a task for reviewing a given file and providing detailed feedback on code quality, bugs, anti-patterns, improvements, and compliance. It constructs a `Task` object with a detailed description and context.
2. **get_file_path_task**: This method generates a task to extract file paths from a provided tree structure of a folder. It returns an array of paths based on whether the input is a file or folder.
3. **content_task**: This method creates a task to fetch the content of a file from GitHub given the owner, repo name, and file path. It uses the GitHub API to retrieve this information.

## Code Review:
### Code Quality:
- The code is generally well-structured and uses descriptive docstrings to explain the purpose and parameters of each method.
- The use of type hints for method parameters adds clarity and improves code readability.

### Bugs:
- There are no apparent bugs in the provided code. The methods handle exceptions using try-except blocks and log any errors that occur.

### Anti-Patterns:
- The import statements for `crewai` can be consolidated to avoid multiple imports from the same module.

### Improvements:
1. **Consolidate Imports:**
   - Instead of importing `Task` and `Agent` separately from `crewai`, import both in a single statement.
2. **Error Handling:**
   - Consider adding more specific error messages for different exceptions to make debugging easier.
3. **Logging:**
   - Enhance logging by including more context in the error messages, such as which method failed.

### Compliance:
- The code adheres to PEP 8 standards for Python with proper indentation, spacing, and naming conventions.

## Updated Code:
```python
import logging
from crewai import Task, Agent  # Consolidated import statement

class Tasks:
    """
    Class to create and manage different types of tasks.
    """

    def review_task(self, agent: Agent, repo: str, path: str, context: str) -> Task:
        """
        Creates a review task for a given file.

        Parameters:
            agent (Agent): The agent responsible for performing the review.
            repo (str): The name of the repository.
            path (str): The file path.
            context (str): The context for the task.

        Returns:
            Task: Configured task for performing the review.
        """
        try:
            return Task(
                agent=agent,
                description=f"""
                    Review the given file and provide detailed feedback and a code review to ensure it adheres to industry code quality standards.

                    - Take the file path and file contents from `content_agent`.
                    - Provide a detailed code review with feedback on the following aspects:
                       * Code Quality
                       * Bugs
                       * Anti-Patterns
                       * Improvements
                       * Compliance
                    - Make necessary improvements to the file content and return the updated content as `updated_code`.

                    Return the following values in the markdown content output:

                    - Project Name: {repo}.
                    - Path: {path}.
                    - Explain This: generate documentation for this code, explain the entire code in a few lines.
                    - Code Review: detailed explain the code review for this code, provide feedback on the code quality, bugs, anti-patterns, improvements, and compliance.
                    - Updated Code: updated code of file after making code review and changes.

                    The attributes returned must be in markdown format, as heading h2 or ## and the value as its nested text.

                    The `Updated Code` output string must be a string in python format. This `Updated Code` output string should be involved by backticks such as ```python updated_code_output ```.

                    Only return the explained and reviewed file content. If there are multiple explains and reviews, return the entire reviewed file content in markdown format.

                    Task output must be a string in markdown format and ensure the markdown content is accurate and well-structured.
                """,
                context=context,
                expected_output="Only return the string output in markdown format and ensure the markdown content is accurate and well-structured."
            )
        except Exception as e:
            logging.error(f"Error creating review task in review_task method: {e}")  # Enhanced logging
            return None

    def get_file_path_task(self, agent: Agent, file_tree: str, repo_directory: str, repo_structure: str, repo_file_sample: str, repo_fullpath_sample: str, repo_output_sample: str) -> Task:
        """
        Creates a task to get the file path from a given tree structure.

        Parameters:
            agent (Agent): The agent responsible for performing the task.
            file_tree (str): The tree structure of the folder.
            repo_directory (str): The user input (file or folder name).

        Returns:
            Task: Configured task for extracting file paths.
        """
        try:
            return Task(
                agent=agent,
                description=f"""
                    You are given a tree structure of folder and repo_directory. First, you have to decide whether it is a folder or file from the given tree structure of a folder.

                    Follow this approach:

                    - If it's a file then return array with 1 element which contains the full path of that file in this folder structure.
                    - If it's a folder then return array of paths of sub files inside that folder. If there is a subfolder in given folder, then return paths for those files as well.
                    - If repo_directory is not present in given tree structure then just return an empty array.

                    Please return the FULL path of a given file in the given folder tree structure. For example, if the tree structure looks like this:

                    {repo_structure}

                    Then the full path of {repo_file_sample} will be "{repo_fullpath_sample}".

                    DON'T send every file content at once, send it one by one to review_agent.

                    Here is the tree structure of the folder:

                    {file_tree}

                    Here is user input:

                    {repo_directory}

                    NOTE: ONLY RETURN ARRAY OF PATHS WITHOUT ANY EXTRA TEXT IN RESPONSE.
                """,
                expected_output=f"""
                    ONLY an array of paths.
                    For example:
                    {repo_output_sample}
                """
            )
        except Exception as e:
            logging.error(f"Error creating file path task in get_file_path_task method: {e}")  # Enhanced logging
            return None

    def content_task(self, agent: Agent, owner: str, repo: str, path: str) -> Task:
        """
        Creates a task to fetch file content using the GitHub API.

        Parameters:
            agent (Agent): The agent responsible for performing the task.
            owner (str): The owner of the repository.
            repo (str): The name of the repository.
            path (str): The file path.

        Returns:
            Task: Configured task for fetching file content.
        """
        try:
            return Task(
                agent=agent,
                description=f"""
                    You are given a file path and you have to get the content of the file and file name using the GitHub API.

                    Here is the file path:

                    {path}

                    Here is the owner name:

                    {owner}

                    Here is the repo name:

                    {repo}

                    Don't return anything except the filename and content.
                """,
                expected_output="filename and content of the given file"
            )
        except Exception as e:
            logging.error(f"Error creating content task in content_task method: {e}")  # Enhanced logging
            return None
```




# src/tools.py



my best complete final answer to the task.


## Project Name: code_challenge_reviewer

## Path: src/tools.py

## Explain This:
The `tools.py` file contains a class `Tools` with a static method `get_file_contents`. This method fetches the content of a file from a GitHub repository using the GitHub API. It takes three parameters: the file path, the repository owner, and the repository name. The method constructs the appropriate API URL, adds the necessary authorization headers, and makes a GET request to the GitHub API. It then processes the response, checking the file size and the number of lines to ensure they are within configurable limits. If these checks pass, the method decodes the Base64 encoded file content and returns it as a string. If any errors occur during the process, appropriate error messages are returned.

## Code Review:
### Code Quality:
- The code is well-structured and follows good practices such as using environment variables for configuration and handling exceptions.
- The use of docstrings to describe the method and its parameters is a good practice.

### Bugs:
- There are no explicit bugs in the code, but there are some potential improvements to enhance error handling and robustness.

### Anti-Patterns:
- The method uses multiple return statements, which can be an anti-pattern as it makes the function harder to follow.
- The class `Tools` does not need to be instantiated, hence the use of a class here seems unnecessary. A module-level function would suffice.

### Improvements:
1. Convert the class to a module as instantiation is not required.
2. Refactor the method to reduce the number of return statements.
3. Add logging for better traceability.
4. Add type hints for better readability and maintainability.
5. Improve error messages to be more user-friendly.

### Compliance:
- The code adheres to general coding standards and practices but could benefit from additional comments and logging.

## Updated Code:
```python
import os
import requests
import base64
from langchain_community.tools import tool
import logging

# Ensure environment variable is set for GITHUB_KEY
GITHUB_KEY = os.getenv('GITHUB_KEY')

if not GITHUB_KEY:
    raise EnvironmentError("GITHUB_KEY environment variable not set")

# Configurable thresholds
MAX_FILE_SIZE = int(os.getenv('MAX_FILE_SIZE', 1000000))  # 1 MB
MAX_LINE_COUNT = int(os.getenv('MAX_LINE_COUNT', 500))  # 500 lines

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@tool("get file contents from given file path")
def get_file_contents(path: str, owner: str, repo: str) -> str:
    """
    Fetches the content of a given file from GitHub using the provided path, owner, and repository name.

    Parameters:
        path (str): The file path or URL.
        owner (str): The owner of the repository.
        repo (str): The name of the repository.

    Returns:
        str: The content of the file or an error message.
    """
    # Construct the API URL
    if path.startswith("https://"):
        api_url = path
    else:
        api_url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"

    # Add the Authorization header with the token
    headers = {
        'Authorization': f'token {GITHUB_KEY}',
        'X-GitHub-Api-Version': '2022-11-28'
    }

    try:
        logger.info(f"Fetching file contents from {api_url}")
        response = requests.get(api_url, headers=headers)
        response.raise_for_status()  # Raise an HTTPError for bad responses (4xx and 5xx)

        file_content = response.json()

        # Check the size of the file
        if file_content['size'] > MAX_FILE_SIZE:  # Configurable file size limit
            logger.warning("Skipped: File size is greater than the configured limit.")
            return "Skipped: File size is greater than the configured limit."

        # Decode the Base64 encoded content
        content_decoded = base64.b64decode(file_content['content'])

        # Convert bytes to string
        content_str = content_decoded.decode('utf-8')

        # Check the number of lines in the file
        if len(content_str.split('\n')) > MAX_LINE_COUNT:  # Configurable line count limit
            logger.warning("Skipped: File contains more lines than the configured limit.")
            return "Skipped: File contains more lines than the configured limit."

        return content_str

    except requests.exceptions.RequestException as e:
        logger.error(f"Request error: {e}")
        return f"Error: {str(e)}"
    except KeyError:
        logger.error("Error: Unexpected response structure from GitHub API")
        return "Error: Unexpected response structure from GitHub API"
    except base64.binascii.Error as e:
        logger.error(f"Base64 decoding error: {e}")
        return f"Error: Base64 decoding failed - {str(e)}"
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        return f"Error: An unexpected error occurred - {str(e)}"
```


