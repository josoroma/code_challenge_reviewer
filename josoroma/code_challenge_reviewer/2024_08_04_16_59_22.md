

# src/agents.py



my best complete final answer to the task.


## Project Name: code_challenge_reviewer

## Path: src/agents.py

## Explain This:
The provided `agents.py` file defines two main classes: `Agents` and `StreamToExpander`.

- **Agents Class**: This class is responsible for creating different types of agents (review, path, content) used for various purposes. Each agent is configured with specific roles, goals, and backstories to handle tasks like code reviews, file path extraction, and content fetching from GitHub.

- **StreamToExpander Class**: This class is designed to write cleaned data to a Streamlit expander object. It removes ANSI escape codes from the data, detects tasks, and displays task notifications using Streamlit's toast feature. It buffers the cleaned data and displays it in the expander when a newline character is detected.

## Code Review:

### Code Quality:
- The code is generally well-structured and uses docstrings to describe class methods.
- Use of `try-except` blocks for error handling is good practice.
- Class and method names are descriptive, adhering to PEP 8 naming conventions.

### Bugs:
- No critical bugs were found in the provided code.

### Anti-Patterns:
- The `color_index` and `colors` attributes in `StreamToExpander` are defined but never used. This is an example of dead code, which should be removed to improve code readability.
- The `tools` parameter in the `content_agent` method is passed a method reference (`Tools.get_file_contents`). It would be better to handle potential errors if `Tools.get_file_contents` is not available or fails at runtime.

### Improvements:
- Remove unused attributes `color_index` and `colors` from `StreamToExpander`.
- Add type hints to methods for better readability and maintainability.
- Handle potential errors when accessing `Tools.get_file_contents` in the `content_agent` method.
- Consider using constants for repeated string literals like error messages.

### Compliance:
- The code complies with PEP 8 standards for the most part.
- Logging is appropriately set to the error level.

## Updated Code:

```python
import re
import logging
from crewai import Agent
import streamlit as st
from tools import Tools

# Set up logging configuration
logging.basicConfig(level=logging.ERROR, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

class Agents:
    """
    Class to create and manage different types of agents.
    """

    REVIEW_AGENT_ROLE = 'Senior Software Developer'
    REVIEW_AGENT_GOAL = 'Perform detailed code reviews on the provided file to ensure it adheres to industry code quality standards. The code review should focus on the following aspects: evaluate code quality, identify bugs, spot anti-patterns, recommend improvements and ensure compliance.'
    REVIEW_AGENT_BACKSTORY = "You are a Senior Software Developer at a leading tech company, responsible for maintaining high code quality standards across the organization. As part of your role, you are tasked with conducting thorough code reviews on given file contents. Your goal is to ensure the code meets industry standards and follows best practices specific to the technologies in use."

    PATH_AGENT_ROLE = "File Path Extractor"
    PATH_AGENT_GOAL = "Get the tree structure of folder and return full paths of the given file or files of given folder in array format"
    PATH_AGENT_BACKSTORY = "You're a file path extractor who has created several file paths from given tree structures"

    CONTENT_AGENT_ROLE = "GitHub API Expert"
    CONTENT_AGENT_GOAL = "Get the content of given file using GitHub API"
    CONTENT_AGENT_BACKSTORY = "You're a GitHub API expert who has extracted many file contents using GitHub's API"

    def review_agent(self) -> Agent:
        """
        Creates a review agent for code reviews.

        Returns:
            Agent: Configured agent for performing code reviews.
        """
        try:
            return Agent(
                role=self.REVIEW_AGENT_ROLE,
                goal=self.REVIEW_AGENT_GOAL,
                backstory=self.REVIEW_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error("Error creating review agent", exc_info=True)
            return None

    def path_agent(self) -> Agent:
        """
        Creates a path agent for extracting file paths.

        Returns:
            Agent: Configured agent for extracting file paths.
        """
        try:
            return Agent(
                role=self.PATH_AGENT_ROLE,
                goal=self.PATH_AGENT_GOAL,
                backstory=self.PATH_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error("Error creating path agent", exc_info=True)
            return None

    def content_agent(self) -> Agent:
        """
        Creates a content agent for fetching file content using GitHub API.

        Returns:
            Agent: Configured agent for fetching file content using GitHub API.
        """
        try:
            tools = [Tools.get_file_contents] if hasattr(Tools, 'get_file_contents') else []
            return Agent(
                role=self.CONTENT_AGENT_ROLE,
                goal=self.CONTENT_AGENT_GOAL,
                backstory=self.CONTENT_AGENT_BACKSTORY,
                verbose=True,
                allow_delegation=False,
                tools=tools,
            )
        except Exception as e:
            logging.error("Error creating content agent", exc_info=True)
            return None

class StreamToExpander:
    def __init__(self, expander):
        self.expander = expander
        self.buffer = []

    def write(self, data: str) -> None:
        """
        Writes cleaned data to the expander.

        Args:
            data (str): The data to be written.
        """
        # Filter out ANSI escape codes using a regular expression
        cleaned_data = re.sub(r'\x1B\[[0-9;]*[mK]', '', data)

        # Check if the data contains 'task' information
        task_match_object = re.search(r'\"task\"\s*:\s*\"(.*?)\"', cleaned_data, re.IGNORECASE)
        task_match_input = re.search(r'task\s*:\s*([^\n]*)', cleaned_data, re.IGNORECASE)

        task_value = None

        if task_match_object:
            task_value = task_match_object.group(1)
        elif task_match_input:
            task_value = task_match_input.group(1).strip()

        if task_value:
            st.toast(":robot_face: " + task_value)

        self.buffer.append(cleaned_data)

        if "\n" in data:
            self.expander.code(''.join(self.buffer), language='bash')
            self.buffer = []

    def clear_buffer(self) -> None:
        """Clears the buffer to free memory."""
        self.buffer = []
```


