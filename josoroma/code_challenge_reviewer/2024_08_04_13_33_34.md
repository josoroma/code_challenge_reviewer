

# src/agents.py




## Project Name: 
code_challenge_reviewer.

## Path: 
src/agents.py.

## Explain This:
The `agents.py` file defines two main classes: `Agents` and `StreamToExpander`. The `Agents` class is responsible for creating and managing different types of agents, each tailored for specific tasks like code reviews, path extraction, and content fetching using the GitHub API. Each method in the class handles the creation of an `Agent` instance and includes error handling with logging. The `StreamToExpander` class is designed to buffer and process output data for display in a Streamlit application, filtering out ANSI escape codes and managing task notifications.

## Code Review:
### Code Quality:
- The code is generally well-structured and adheres to principles of OOP. However, there are areas where readability could be enhanced, particularly in the `StreamToExpander` class.

### Bugs:
- No critical bugs were found in the code. All methods that create agents handle exceptions and log errors appropriately.

### Anti-Patterns:
- The use of hard-coded strings for roles and goals might lead to maintenance challenges. Consider using constants or configuration files for better manageability.

### Improvements:
1. **Docstrings**: While some methods have docstrings, adding more detailed explanations for parameters and return types would improve the documentation.
2. **Logging Levels**: The logging level is set to `ERROR`, which may not capture all necessary information during development. Consider using `DEBUG` or `INFO` levels where appropriate.
3. **Color Management**: The color management in `StreamToExpander` is not utilized in the current implementation. If colors are not needed, consider removing this feature to simplify the class.
4. **Regular Expressions**: The regex patterns used for extracting tasks could be improved for better performance and clarity.

### Compliance:
- The code mostly follows PEP 8 guidelines but could benefit from more consistent spacing and line lengths. Ensure that the code is aligned with your organization's specific style guide.

## Updated Code:
```python
import re
import logging
from crewai import Agent
import streamlit as st
from tools import Tools

# Set up logging configuration
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

class Agents:
    """
    Class to create and manage different types of agents.
    """
    # Constants for agent roles and goals
    REVIEW_AGENT_ROLE = 'Senior Software Developer'
    REVIEW_AGENT_GOAL = 'Perform detailed code reviews on the provided file to ensure it adheres to industry code quality standards. The code review should focus on the following aspects: evaluate code quality, identify bugs, spot anti-patterns, recommend improvements and ensure compliance.'
    REVIEW_AGENT_BACKSTORY = "You are a Senior Software Developer at a leading tech company, responsible for maintaining high code quality standards across the organization. As part of your role, you are tasked with conducting thorough code reviews on given file contents. Your goal is to ensure the code meets industry standards and follows best practices specific to the technologies in use."

    PATH_AGENT_ROLE = "File Path Extractor"
    PATH_AGENT_GOAL = "Get the tree structure of folder and return full paths of the given file or files of given folder in array format"
    PATH_AGENT_BACKSTORY = "You're a file path extractor who has created several file paths from given tree structures"

    CONTENT_AGENT_ROLE = "GitHub API Expert"
    CONTENT_AGENT_GOAL = "Get the content of given file using GitHub API"
    CONTENT_AGENT_BACKSTORY = "You're a GitHub API expert who has extracted many file contents using GitHub's API"

    def review_agent(self):
        """
        Creates a review agent for code reviews.

        Returns:
            Agent: Configured agent for performing code reviews.
        """
        try:
            return Agent(
                role=self.REVIEW_AGENT_ROLE,
                goal=self.REVIEW_AGENT_GOAL,
                backstory=self.REVIEW_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error("Error creating review agent: %s", e, exc_info=True)
            return None

    def path_agent(self):
        """
        Creates a path agent for extracting file paths.

        Returns:
            Agent: Configured agent for extracting file paths.
        """
        try:
            return Agent(
                role=self.PATH_AGENT_ROLE,
                goal=self.PATH_AGENT_GOAL,
                backstory=self.PATH_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error("Error creating path agent: %s", e, exc_info=True)
            return None

    def content_agent(self):
        """
        Creates a content agent for fetching file content using GitHub API.

        Returns:
            Agent: Configured agent for fetching file content using GitHub API.
        """
        try:
            return Agent(
                role=self.CONTENT_AGENT_ROLE,
                goal=self.CONTENT_AGENT_GOAL,
                backstory=self.CONTENT_AGENT_BACKSTORY,
                verbose=True,
                allow_delegation=False,
                tools=[Tools.get_file_contents],
            )
        except Exception as e:
            logging.error("Error creating content agent: %s", e, exc_info=True)
            return None

class StreamToExpander:
    def __init__(self, expander):
        self.expander = expander
        self.buffer = []

    def write(self, data):
        # Filter out ANSI escape codes using a regular expression
        cleaned_data = re.sub(r'\x1B\[[0-9;]*[mK]', '', data)

        # Check if the data contains 'task' information
        task_match_object = re.search(r'\"task\"\s*:\s*\"(.*?)\"', cleaned_data, re.IGNORECASE)
        task_match_input = re.search(r'task\s*:\s*([^\n]*)', cleaned_data, re.IGNORECASE)

        task_value = None

        if task_match_object:
            task_value = task_match_object.group(1)
        elif task_match_input:
            task_value = task_match_input.group(1).strip()

        if task_value:
            st.toast(":robot_face: " + task_value)

        self.buffer.append(cleaned_data)

        if "\n" in data:
            self.expander.code(''.join(self.buffer), language='bash')
            self.buffer = []

    def clear_buffer(self):
        """Clears the buffer to free memory."""
        self.buffer = []
```




# src/constants.py



## Project Name: code_challenge_reviewer

## Path: src/constants.py

## Explain This:
This Python file defines a set of constant values that are used throughout the application. Constants help maintain code clarity and avoid the use of magic numbers or strings within the codebase, promoting better maintainability and readability.

## Code Review:
1. **Code Quality**: The code is generally well-structured and uses uppercase naming conventions for constants, which is a standard practice in Python. However, adding type hints would improve readability and help with static type checking.

2. **Bugs**: No immediate bugs are present, but it's essential to ensure that the values assigned to constants are accurate and reflect the intended use throughout the application. 

3. **Anti-Patterns**: The file contains hard-coded values. While constants are useful, if these values are used in multiple places, consider loading them from a configuration file or environment variables for flexibility and easier management.

4. **Improvements**: 
   - Add type hints for better clarity.
   - Group related constants together and consider adding comments to describe their purpose.
   - If constants are used in multiple modules, consider using a dedicated configuration module.

5. **Compliance**: The code mostly adheres to PEP 8 standards, but ensuring consistent spacing and line length (preferably under 79 characters) would enhance compliance. 

## Updated Code:
```python
# Constants used throughout the application

# HTTP status codes
HTTP_OK: int = 200
HTTP_NOT_FOUND: int = 404
HTTP_INTERNAL_SERVER_ERROR: int = 500

# Application-specific constants
DEFAULT_PAGE_SIZE: int = 20
MAX_RETRIES: int = 5

# Time out settings in seconds
TIMEOUT_CONNECT: int = 10
TIMEOUT_READ: int = 30




# src/github_helper.py




## Project Name
code_challenge_reviewer.

## Path
src/github_helper.py.

## Explain This
This code defines a function that retrieves and prints the tree structure of a specified GitHub repository. It connects to the GitHub API using an authorization token from an environment variable, handles HTTP requests to fetch the repository contents, and formats the directory structure while ignoring specified folders.

## Code Review
### Code Quality
- The overall structure and flow of the code are good. The function is well-defined with a clear purpose. However, some improvements can be made for readability and maintainability.

### Bugs
- The current implementation does not handle cases where the GitHub repository might not exist or is private, leading to potential unhandled exceptions.
- No return value is defined for the case when the fetched items are not a list.

### Anti-Patterns
- Using general exception handling (`except Exception as e`) can mask underlying issues and make debugging difficult. It's better to handle specific exceptions.
- The function uses too many nested try-except blocks, which can complicate the flow of error handling.

### Improvements
- Consider adding a check for the response status code to ensure the repository is accessible before attempting to parse the JSON response.
- Return an explicit error message or raise an exception when the response is not as expected.
- Extract the logic for making the API request into a separate function to enhance modularity and reuse.
- Improve logging by providing more context in the log messages.

### Compliance
- The code adheres to PEP 8 style guidelines in terms of naming conventions and spacing.
- Function docstring is present and follows the conventions, but could include more details regarding exceptions raised.

## Updated Code
```python
import os
import requests
import streamlit as st
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)

# Ensure environment variable is set for GITHUB_KEY
GITHUB_KEY = os.getenv('GITHUB_KEY')
if not GITHUB_KEY:
    logging.error("GITHUB_KEY environment variable not set.")
    raise ValueError("GITHUB_KEY environment variable not set.")

def fetch_repository_contents(api_url: str, headers: dict) -> list:
    """Fetch contents from GitHub repository."""
    response = requests.get(api_url, headers=headers, verify=True)
    response.raise_for_status()  # Raise an error for bad responses
    return response.json()

def get_file_tree(owner: str, repo: str, path: str = "", level: int = 0, max_depth: int = 10) -> str:
    """
    Fetch and print the tree structure of a GitHub repository, ignoring specific folders.

    Parameters:
    - owner: The username of the repository owner.
    - repo: The name of the repository.
    - path: The path to fetch. Leave empty to fetch the root directory.
    - level: The current depth in the tree structure.
    - max_depth: The maximum depth to recurse into directories.

    Returns:
    - str: The tree structure as a string, or an error message if fetching fails.
    """
    ignore_dirs = {'public', 'images', 'media', 'assets'}

    if level > max_depth:
        return ""

    api_url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"
    headers = {'Authorization': f'token {GITHUB_KEY}'}
    
    output = ""

    try:
        items = fetch_repository_contents(api_url, headers)

        if isinstance(items, list):
            for item in items:
                if item['name'] in ignore_dirs:
                    continue

                item_name = f"{' ' * (level * 2)}- {item['name']}"
                output += f"{item_name}\n"

                if item['type'] == 'dir':
                    output += get_file_tree(owner, repo, item['path'], level + 1, max_depth)

        return output

    except requests.exceptions.HTTPError as http_err:
        logging.error(f"HTTP error occurred: {http_err}. Unable to fetch contents.")
        return "Error: Unable to fetch contents."
    except requests.exceptions.ConnectionError as conn_err:
        logging.error(f"Connection error occurred: {conn_err}. Check your network connection.")
        return "Error: Connection error."
    except requests.exceptions.Timeout as timeout_err:
        logging.error(f"Timeout error occurred: {timeout_err}. The request timed out.")
        return "Error: Request timeout."
    except requests.exceptions.RequestException as req_err:
        logging.error(f"Request error: {req_err}.")
        return "Error: Request failed."
    except ValueError:
        logging.error("Error: Unable to parse the response from GitHub.")
        return "Error: Unable to parse response."
    except Exception as e:
        logging.error(f"Unexpected error occurred: {str(e)}.")
        return f"Error: {str(e)}."
```




# src/review_crew.py




## Project Name
code_challenge_reviewer.

## Path
src/review_crew.py.

## Explain This
The `ReviewCrew` class is designed to manage the review process of a specified file within a GitHub repository. It initializes with repository details such as the owner, repository name, file path, and output path. The class includes methods to append review results to a markdown file and execute the review process using defined agents and tasks. The logging mechanism captures errors during file operations and the review process.

## Code Review
- **Code Quality**: The code is generally well-structured and uses appropriate naming conventions. However, there are areas where readability can be improved, such as adding more comments and breaking down complex lines into simpler statements.
  
- **Bugs**: The code does not appear to have any overt bugs; however, the exception handling could be more specific rather than catching all exceptions together. This would help in debugging.

- **Anti-Patterns**: The current implementation of `append_review_to_file` method mixes file I/O operations with logging. It's better to separate concerns, for instance by creating a dedicated method for logging errors related to file writing.

- **Improvements**: 
  - Consider using type hints for method parameters and return types to enhance code clarity.
  - Improve exception handling by catching specific exceptions (e.g., `IOError` for file operations).
  - Add docstrings for all methods in the class to maintain consistency and improve documentation.
  - Ensure that logging captures more detailed information about the context of errors.

- **Compliance**: The code adheres to basic Python standards but could benefit from more comprehensive testing and adherence to PEP 8 style guidelines, particularly in terms of line length and spacing.

## Updated Code
```python
import os
import re
import streamlit as st
import logging
from crewai import Crew
from agents import Agents
from tasks import Tasks

# Create a custom logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# Create handlers
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)

# Create formatters and add them to the handlers
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)

# Add handlers to the logger
logger.addHandler(console_handler)


class ReviewCrew:
    """
    Class to handle the review process for a given file in a GitHub repository.
    """

    def __init__(self, owner: str, repo: str, path: str, output: str):
        """
        Initializes the ReviewCrew with the repository details.

        Parameters:
            owner (str): The owner of the repository.
            repo (str): The name of the repository.
            path (str): The path of the file to review.
            output (str): The path of the single file with all the repo files reviewed.
        """
        self.owner = owner
        self.repo = repo
        self.path = path
        self.output = output
        self.output_placeholder = st.empty()

    def append_review_to_file(self, result: str) -> None:
        """
        Appends the explain and the review result to a markdown file.

        Parameters:
            result (str): The str containing the explain and the review results in markdown format.
        """
        # Create directory path using owner and repo
        dir_path = os.path.join(self.owner, self.repo)
        os.makedirs(dir_path, exist_ok=True)

        # Create a file with the current date as its name
        file_path = os.path.join(dir_path, self.output)

        try:
            with open(file_path, 'a') as file:
                file.write(f"\n\n# {self.repo} - {self.path}\n\n")
                file.write(result)
        except IOError as e:
            logger.error(f"Error writing to file: {e}")

    def run(self) -> str:
        """
        Runs the review process using the defined agents and tasks.
        """
        try:
            # The Agents
            agents = Agents()
            review_agent = agents.review_agent()
            content_agent = agents.content_agent()

            # The Tasks
            tasks = Tasks()
            content_task = tasks.content_task(
                agent=content_agent,
                owner=self.owner,
                repo=self.repo,
                path=self.path
            )
            review_task = tasks.review_task(
                agent=review_agent,
                repo=self.repo,
                path=self.path,
                context=[content_task]
            )

            # The Crew
            crew = Crew(
                agents=[content_agent, review_agent],
                tasks=[content_task, review_task],
                verbose=2,
                telemetry=False
            )

            # Run the crew
            kickoff_result = crew.kickoff()

            str_result = str(kickoff_result).strip()

            result = re.sub(r'^```markdown|```$', '', str_result, flags=re.DOTALL)

            self.append_review_to_file(f"\n\n{result}\n\n")

            self.output_placeholder.code(f"\n\n{result}\n\n", language='markdown')

            return result

        except Exception as e:
            logger.error(f"Error running ReviewCrew: {e}")
```  




# src/tasks.py




## Project Name:
code_challenge_reviewer.

## Path:
src/tasks.py.

## Explain This:
This code defines a `Tasks` class responsible for creating and managing different types of tasks related to code reviews and file content retrieval using the GitHub API. It includes methods to create review tasks, fetch file paths from a directory structure, and retrieve file content.

## Code Review:
The code quality is generally good, but there are areas for improvement:

1. **Code Quality**: 
   - The code is well-structured and uses meaningful variable names. However, the inline comments could be improved for clarity, especially in complex sections.
   - The use of formatted strings for descriptions is appropriate, though it could be beneficial to format them more cleanly for readability.

2. **Bugs**: 
   - No apparent bugs were found in the given code. However, error handling in the `try-except` blocks is basic. It would be helpful to raise specific exceptions rather than logging a generic error.

3. **Anti-Patterns**: 
   - The use of `try-except` without handling specific exceptions can lead to masking bugs. It is better to catch specific exceptions to make debugging easier.
   - The method `review_task` has a large block of code in the description string which could be moved to a separate constant or method to improve readability.

4. **Improvements**: 
   - Consider adding type hints for all method parameters and return types for better clarity and tooling support.
   - Improve exception handling by specifying expected exceptions.
   - Add unit tests for each method to ensure functionality and maintainability. 

5. **Compliance**: 
   - The code generally adheres to PEP 8 standards, but line lengths in some places exceed 79 characters. Refactoring some strings can help maintain the standard.
   - Documentation is present but could be more detailed, especially concerning the purpose of each method.

## Updated Code:
```python
from crewai import Task
import logging
from crewai import Agent

class Tasks:
    """
    Class to create and manage different types of tasks.
    """

    def review_task(self, agent: Agent, repo: str, path: str, context: str) -> Task:
        """
        Creates a review task for a given file.

        Parameters:
            agent (Agent): The agent responsible for performing the review.
            repo (str): The name of the repository.
            path (str): The file path.
            context (str): The context for the task.

        Returns:
            Task: Configured task for performing the review.
        """
        try:
            description = (
                "Review the given file and provide detailed feedback and a code review to ensure it adheres to industry code quality standards.\n\n"
                "- Take the file path and file contents from `content_agent`.\n"
                "- Provide a detailed code review with feedback on the following aspects:\n"
                "   * Code Quality\n"
                "   * Bugs\n"
                "   * Anti-Patterns\n"
                "   * Improvements\n"
                "   * Compliance\n"
                "- Make necessary improvements to the file content and return the updated content as `updated_code`.\n\n"
                "Return the following values in the markdown content output:\n\n"
                "- Project Name: {repo}.\n"
                "- Path: {path}.\n"
                "- Explain This: generate documentation for this code, explain the entire code in a few lines.\n"
                "- Code Review: detailed explain the code review for this code, provide feedback on the code quality, bugs, anti-patterns, improvements, and compliance.\n"
                "- Updated Code: updated code of file after making code review and changes.\n\n"
                "The attributes returned must be in markdown format, as heading h2 or ## and the value as its nested text.\n\n"
                "The `Updated Code` output string must be a string in python format. This `Updated Code` output string should be involved by backticks such as ```python updated_code_output ```.\n\n"
                "Only return the explained and reviewed file content. If there are multiple explains and reviews, return the entire reviewed file content in markdown format.\n\n"
                "Task output must be a string in markdown format and ensure the markdown content is accurate and well-structured."
            )
            return Task(
                agent=agent,
                description=description,
                context=context,
                expected_output="Only return the string output in markdown format and ensure the markdown content is accurate and well-structured."
            )
        except Exception as e:
            logging.error(f"Error creating review task: {e}")
            return None

    def get_file_path_task(self, agent: Agent, file_tree: str, repo_directory: str, repo_structure: str, repo_file_sample: str, repo_fullpath_sample: str, repo_output_sample: str) -> Task:
        """
        Creates a task to get the file path from a given tree structure.

        Parameters:
            agent (Agent): The agent responsible for performing the task.
            file_tree (str): The tree structure of the folder.
            repo_directory (str): The user input (file or folder name).

        Returns:
            Task: Configured task for extracting file paths.
        """
        try:
            return Task(
                agent=agent,
                description=f"""
                    You are given a tree structure of folder and repo_directory. First, you have to decide whether it is a folder or file from the given tree structure of a folder.

                    Follow this approach:

                    - If it's a file then return array with 1 element which contains the full path of that file in this folder structure.
                    - If it's a folder then return array of paths of sub files inside that folder. If there is a subfolder in given folder, then return paths for those files as well.
                    - If repo_directory is not present in given tree structure then just return an empty array.

                    Please return the FULL path of a given file in the given folder tree structure. For example, if the tree structure looks like this:

                    {repo_structure}

                    Then the full path of {repo_file_sample} will be "{repo_fullpath_sample}".

                    DON'T send every file content at once, send it one by one to review_agent.

                    Here is the tree structure of the folder:

                    {file_tree}

                    Here is user input:

                    {repo_directory}

                    NOTE: ONLY RETURN ARRAY OF PATHS WITHOUT ANY EXTRA TEXT IN RESPONSE.
                """,
                expected_output=f"""
                    ONLY an array of paths.
                    For example:
                    {repo_output_sample}
                """
            )
        except Exception as e:
            logging.error(f"Error creating file path task: {e}")
            return None

    def content_task(self, agent: Agent, owner: str, repo: str, path: str) -> Task:
        """
        Creates a task to fetch file content using the GitHub API.

        Parameters:
            agent (Agent): The agent responsible for performing the task.
            owner (str): The owner of the repository.
            repo (str): The name of the repository.
            path (str): The file path.

        Returns:
            Task: Configured task for fetching file content.
        """
        try:
            return Task(
                agent=agent,
                description=f"""
                    You are given a file path and you have to get the content of the file and file name using the GitHub API.

                    Here is the file path:

                    {path}

                    Here is the owner name:

                    {owner}

                    Here is the repo name:

                    {repo}

                    Don't return anything except the filename and content.
                """,
                expected_output="filename and content of the given file"
            )
        except Exception as e:
            logging.error(f"Error creating content task: {e}")
            return None
```




# src/tools.py




## Project Name
code_challenge_reviewer.

## Path
src/tools.py.

## Explain This
This code defines a method to fetch file contents from a GitHub repository using the GitHub API. It checks for appropriate environment variables, validates the file size and line count against configurable thresholds, and handles various potential errors during the API request and response processing.

## Code Review
### Code Quality
The code is generally well-structured and employs clear naming conventions. However, there are areas that can be improved for better readability and maintainability. The use of magic numbers (e.g., the default values for `MAX_FILE_SIZE` and `MAX_LINE_COUNT`) should be avoided in favor of named constants.

### Bugs
No critical bugs were identified in the code. The error handling covers a range of exceptions that could arise from the API calls and decoding processes.

### Anti-Patterns
- The use of hardcoded date in the `X-GitHub-Api-Version` header might lead to issues if the API version changes. Itâ€™s better to manage this through a configuration file or environment variable.
- The method `get_file_contents` could benefit from breaking down its responsibilities. For instance, the logic for checking file size and line count could be encapsulated into separate helper methods to adhere to the Single Responsibility Principle.

### Improvements
1. **Constants for Magic Numbers:** Define constants for the configurable limits to improve code readability.
2. **Helper Methods:** Create helper methods for file size and line count validation.
3. **Error Handling:** Consider using logging instead of returning strings for error handling, which can provide better insight during debugging.
4. **Documentation:** The docstring could elaborate more on the exceptions that might be raised for better clarity.

### Compliance
The code is compliant with Python's PEP 8 style guide overall, but some improvements in formatting and documentation will enhance compliance further.

## Updated Code
```python
import os
import requests
import base64
from langchain_community.tools import tool

# Ensure environment variable is set for GITHUB_KEY
GITHUB_KEY = os.getenv('GITHUB_KEY')

if not GITHUB_KEY:
    raise EnvironmentError("GITHUB_KEY environment variable not set")

# Configurable thresholds
MAX_FILE_SIZE = int(os.getenv('MAX_FILE_SIZE', 1000000))  # 1 MB
MAX_LINE_COUNT = int(os.getenv('MAX_LINE_COUNT', 500))  # 500 lines

class Tools():
    @staticmethod
    @tool("get file contents from given file path")
    def get_file_contents(path, owner, repo):
        """
        Fetches the content of a given file from GitHub using the provided path, owner, and repository name.

        Parameters:
            path (str): The file path or URL.
            owner (str): The owner of the repository.
            repo (str): The name of the repository.

        Returns:
            str: The content of the file or an error message.
        Raises:
            EnvironmentError: If GITHUB_KEY is not set.
            requests.exceptions.RequestException: If the request to the GitHub API fails.
            KeyError: If the response from GitHub API does not have expected structure.
            base64.binascii.Error: If Base64 decoding fails.
        """
        # Construct the API URL
        api_url = path if path.startswith("https://") else f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"

        # Add the Authorization header with the token
        headers = {
            'Authorization': f'token {GITHUB_KEY}',
            'X-GitHub-Api-Version': '2022-11-28'  # Consider moving to a config
        }

        try:
            response = requests.get(api_url, headers=headers)
            response.raise_for_status()  # Raise an HTTPError for bad responses (4xx and 5xx)

            file_content = response.json()

            # Check the size of the file
            if file_content['size'] > MAX_FILE_SIZE:  # Configurable file size limit
                return "Skipped: File size is greater than the configured limit."

            # Decode the Base64 encoded content
            content_decoded = base64.b64decode(file_content['content'])

            # Convert bytes to string
            content_str = content_decoded.decode('utf-8')

            # Check the number of lines in the file
            if len(content_str.split('\n')) > MAX_LINE_COUNT:  # Configurable line count limit
                return "Skipped: File contains more lines than the configured limit."

            return content_str

        except requests.exceptions.RequestException as e:
            return f"Error: {str(e)}"
        except KeyError:
            return "Error: Unexpected response structure from GitHub API"
        except base64.binascii.Error as e:
            return f"Error: Base64 decoding failed - {str(e)}"
        except Exception as e:
            return f"Error: An unexpected error occurred - {str(e)}"
```


