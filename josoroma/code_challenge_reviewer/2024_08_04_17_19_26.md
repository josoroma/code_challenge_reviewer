

# src/agents.py



my best complete final answer to the task.


# code_challenge_reviewer

## Path: src/agents.py

### Explain This
The `src/agents.py` file defines an `Agents` class responsible for creating different types of agents, each with a specific role, goal, and backstory. These agents include a review agent for conducting code reviews, a path agent for extracting file paths, and a content agent for fetching file contents using the GitHub API. Additionally, there is a `StreamToExpander` class that handles displaying log data in a Streamlit expander widget, filtering out ANSI escape codes and displaying task-related information as toasts.

### Code Review
#### Code Quality
- The overall code quality is decent, with clear docstrings and consistent naming conventions.
- Exception handling is in place, but can be improved by providing more context-specific error messages.

#### Bugs
- No critical bugs are immediately apparent in the given code.

#### Anti-Patterns
- **Hardcoding Values**: The `colors` list and `color_index` in the `StreamToExpander` class are hardcoded, which can be avoided by making them configurable.
- **Exception Handling**: Using generic `Exception` in `except` blocks can be improved by catching specific exceptions.
- **Redundant Regular Expression Checks**: The `task_match_object` and `task_match_input` regular expression checks in `StreamToExpander` can be optimized.

#### Improvements
- **Configuration Management**: Externalize the hardcoded values for better maintainability.
- **Specific Exception Handling**: Catch specific exceptions instead of generic ones.
- **Optimized Regex Usage**: Combine or optimize the regex checks in `StreamToExpander`.

#### Compliance
- The code largely adheres to industry standards and best practices, including logging and documentation.
- Ensure compliance with PEP 8 for Python code style.

### Updated Code
```python
import re
import logging
from crewai import Agent
import streamlit as st
from tools import Tools

# Set up logging configuration
logging.basicConfig(level=logging.ERROR, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

class Agents:
    """
    Class to create and manage different types of agents.
    """

    REVIEW_AGENT_ROLE = 'Senior Software Developer'
    REVIEW_AGENT_GOAL = 'Perform detailed code reviews on the provided file to ensure it adheres to industry code quality standards. The code review should focus on the following aspects: evaluate code quality, identify bugs, spot anti-patterns, recommend improvements and ensure compliance. NOTE: Return the entire output formatted as Markdown, enclosed within triple backticks like this:  output```'
    REVIEW_AGENT_BACKSTORY = "You are a Senior Software Developer at a leading tech company, responsible for maintaining high code quality standards across the organization. As part of your role, you are tasked with conducting thorough code reviews on given file contents. Your goal is to ensure the code meets industry standards and follows best practices specific to the technologies in use."

    PATH_AGENT_ROLE = "File Path Extractor"
    PATH_AGENT_GOAL = "Get the tree structure of folder and return full paths of the given file or files of given folder in array format"
    PATH_AGENT_BACKSTORY = "You're a file path extractor who has created several file paths from given tree structures"

    CONTENT_AGENT_ROLE = "GitHub API Expert"
    CONTENT_AGENT_GOAL = "Get the content of given file using GitHub API"
    CONTENT_AGENT_BACKSTORY = "You're a GitHub API expert who has extracted many file contents using GitHub's API"

    def review_agent(self):
        """
        Creates a review agent for code reviews.

        Returns:
            Agent: Configured agent for performing code reviews.
        """
        try:
            return Agent(
                role=self.REVIEW_AGENT_ROLE,
                goal=self.REVIEW_AGENT_GOAL,
                backstory=self.REVIEW_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except (AgentError, ValueError) as e:
            logging.error("Error creating review agent: %s", e, exc_info=True)
            return None

    def path_agent(self):
        """
        Creates a path agent for extracting file paths.

        Returns:
            Agent: Configured agent for extracting file paths.
        """
        try:
            return Agent(
                role=self.PATH_AGENT_ROLE,
                goal=self.PATH_AGENT_GOAL,
                backstory=self.PATH_AGENT_BACKSTORY,
                allow_delegation=False,
                verbose=True,
            )
        except (AgentError, ValueError) as e:
            logging.error("Error creating path agent: %s", e, exc_info=True)
            return None

    def content_agent(self):
        """
        Creates a content agent for fetching file content using GitHub API.

        Returns:
            Agent: Configured agent for fetching file content using GitHub API.
        """
        try:
            return Agent(
                role=self.CONTENT_AGENT_ROLE,
                goal=self.CONTENT_AGENT_GOAL,
                backstory=self.CONTENT_AGENT_BACKSTORY,
                verbose=True,
                allow_delegation=False,
                tools=[Tools.get_file_contents],
            )
        except (AgentError, ValueError) as e:
            logging.error("Error creating content agent: %s", e, exc_info=True)
            return None

class StreamToExpander:
    def __init__(self, expander, colors=None):
        self.expander = expander
        self.buffer = []
        self.colors = colors or ['red', 'green', 'blue', 'orange']  # Use provided colors or default
        self.color_index = 0  # Initialize color index

    def write(self, data):
        # Filter out ANSI escape codes using a regular expression
        cleaned_data = re.sub(r'\x1B\[[0-9;]*[mK]', '', data)

        # Check if the data contains 'task' information
        task_match = re.search(r'\"?task\"?\s*:\s*\"?([^\"]*)\"?', cleaned_data, re.IGNORECASE)

        if task_match:
            task_value = task_match.group(1).strip()
            st.toast(":robot_face: " + task_value)

        self.buffer.append(cleaned_data)

        if "\n" in data:
            self.expander.code(''.join(self.buffer), language='bash')
            self.buffer = []

    def clear_buffer(self):
        """Clears the buffer to free memory."""
        self.buffer = []
```


