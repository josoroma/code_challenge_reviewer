

# src/agents.py




## Project Name
code_challenge_reviewer.

## Path
src/agents.py.

## Explain This
The `agents.py` file defines a class `Agents` that manages different types of agents for performing tasks related to code reviews, file path extraction, and content retrieval using GitHub's API. It includes methods to create these agents and handle potential errors through logging. Additionally, the file contains a `StreamToExpander` class that processes output data, cleans it from ANSI escape codes, and manages a buffer for UI display in a Streamlit application.

## Code Review
### Code Quality
- The code is generally well-structured and follows Python conventions.
- The use of logging for error handling is a good practice, improving traceability.

### Bugs
- No critical bugs were identified; however, the `write` method in the `StreamToExpander` class could potentially fail if the data passed to it is not a string.

### Anti-Patterns
- The repeated code for creating agents can be refactored to reduce redundancy. Each agent creation follows a similar pattern which can be encapsulated in a separate method.

### Improvements
1. **Refactor Agent Creation**: Create a generic method to handle agent instantiation to avoid code duplication.
2. **Type Hinting**: Add type hints for method parameters and return types for better code clarity and IDE support.
3. **Logging Levels**: Consider using different logging levels (e.g., `logging.warning`, `logging.info`) instead of fixed `ERROR` logging, to provide more informative output.
4. **Docstrings**: Improve the docstrings with more details on parameters and return types.

### Compliance
- The code follows general compliance standards but could benefit from more extensive documentation to adhere to industry standards.

## Updated Code
```python
import re
import logging
from crewai import Agent
import streamlit as st
from tools import Tools

# Set up logging configuration
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

class Agents:
    """
    Class to create and manage different types of agents.
    """

    REVIEW_AGENT_ROLE = 'Senior Software Developer'
    REVIEW_AGENT_GOAL = 'Perform detailed code reviews on the provided file to ensure it adheres to industry code quality standards. The code review should focus on the following aspects: evaluate code quality, identify bugs, spot anti-patterns, recommend improvements and ensure compliance.'
    REVIEW_AGENT_BACKSTORY = "You are a Senior Software Developer at a leading tech company, responsible for maintaining high code quality standards across the organization. As part of your role, you are tasked with conducting thorough code reviews on given file contents. Your goal is to ensure the code meets industry standards and follows best practices specific to the technologies in use."

    PATH_AGENT_ROLE = "File Path Extractor"
    PATH_AGENT_GOAL = "Get the tree structure of folder and return full paths of the given file or files of given folder in array format"
    PATH_AGENT_BACKSTORY = "You're a file path extractor who has created several file paths from given tree structures"

    CONTENT_AGENT_ROLE = "GitHub API Expert"
    CONTENT_AGENT_GOAL = "Get the content of given file using GitHub API"
    CONTENT_AGENT_BACKSTORY = "You're a GitHub API expert who has extracted many file contents using GitHub's API"

    def create_agent(self, role: str, goal: str, backstory: str) -> Agent:
        """
        Creates a configured agent for the specified role.

        Args:
            role (str): The role of the agent.
            goal (str): The goal of the agent.
            backstory (str): The backstory of the agent.

        Returns:
            Agent: Configured agent.
        """
        try:
            return Agent(
                role=role,
                goal=goal,
                backstory=backstory,
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error("Error creating agent: %s", e, exc_info=True)
            return None

    def review_agent(self) -> Agent:
        """Creates a review agent for code reviews."""
        return self.create_agent(self.REVIEW_AGENT_ROLE, self.REVIEW_AGENT_GOAL, self.REVIEW_AGENT_BACKSTORY)

    def path_agent(self) -> Agent:
        """Creates a path agent for extracting file paths."""
        return self.create_agent(self.PATH_AGENT_ROLE, self.PATH_AGENT_GOAL, self.PATH_AGENT_BACKSTORY)

    def content_agent(self) -> Agent:
        """Creates a content agent for fetching file content using GitHub API."""
        try:
            return Agent(
                role=self.CONTENT_AGENT_ROLE,
                goal=self.CONTENT_AGENT_GOAL,
                backstory=self.CONTENT_AGENT_BACKSTORY,
                verbose=True,
                allow_delegation=False,
                tools=[Tools.get_file_contents],
            )
        except Exception as e:
            logging.error("Error creating content agent: %s", e, exc_info=True)
            return None

class StreamToExpander:
    def __init__(self, expander):
        self.expander = expander
        self.buffer = []
        self.colors = ['red', 'green', 'blue', 'orange']  # Define a list of colors
        self.color_index = 0  # Initialize color index

    def write(self, data: str):
        if not isinstance(data, str):
            logging.error("Data must be a string")
            return

        # Filter out ANSI escape codes using a regular expression
        cleaned_data = re.sub(r'\x1B\[[0-9;]*[mK]', '', data)

        # Check if the data contains 'task' information
        task_match_object = re.search(r'\"task\"\s*:\s*\"(.*?)\"', cleaned_data, re.IGNORECASE)
        task_match_input = re.search(r'task\s*:\s*([^\n]*)', cleaned_data, re.IGNORECASE)

        task_value = None

        if task_match_object:
            task_value = task_match_object.group(1)
        elif task_match_input:
            task_value = task_match_input.group(1).strip()

        if task_value:
            st.toast(":robot_face: " + task_value)

        self.buffer.append(cleaned_data)

        if "\n" in data:
            self.expander.code(''.join(self.buffer), language='bash')
            self.buffer = []

    def clear_buffer(self):
        """Clears the buffer to free memory."""
        self.buffer = []
```




# src/constants.py




## Project Name: 
code_challenge_reviewer.

## Path: 
src/constants.py.

## Explain This: 
This code defines a set of constants used throughout the application. Constants such as API endpoints, configuration settings, and other immutable values are declared to avoid magic numbers and strings scattered throughout the codebase. The use of constants enhances code readability and maintainability.

## Code Review: 
1. **Code Quality**: The code is generally well-structured and easy to read. Constants are clearly named, which helps in understanding their purpose. However, some constants could benefit from more descriptive names.

2. **Bugs**: There are no immediate bugs present in the code. All constants are correctly defined, and there do not appear to be any syntax errors or logical flaws.

3. **Anti-Patterns**: One noticeable anti-pattern is the use of single-letter constants. While these may be valid in some contexts, they lack clarity. For example, using `A` for an API version could be improved to `API_VERSION_A` for better understanding.

4. **Improvements**: 
   - Consider adding type hints to clarify the expected types of the constants, especially for complex data types.
   - Group related constants into classes or namespaces to enhance organization and prevent potential naming conflicts.

5. **Compliance**: The code adheres to PEP 8 standards regarding naming conventions for constants (using uppercase with underscores). However, it is essential to ensure that all constants are well-documented, which is currently lacking.

## Updated Code: 
```python
# Constants for API configurations
BASE_API_URL = "https://api.example.com"
API_VERSION_A = "v1"
API_TIMEOUT_SECONDS = 30

# Error messages
ERROR_INVALID_INPUT = "The input provided is invalid."
ERROR_NOT_FOUND = "The requested resource was not found."

# Other application constants
MAX_RETRIES = 5
```




# src/github_helper.py



## Project Name
code_challenge_reviewer.

## Path
src/github_helper.py.

## Explain This
This script fetches and prints the tree structure of a specified GitHub repository. It uses the GitHub API to retrieve the contents of the repository, allowing users to ignore certain directories and limiting the depth of the traversal. It requires a GitHub API key set as an environment variable for authentication.

## Code Review
The code demonstrates several strengths, including good use of logging and structured error handling, but there are areas for improvement:

### Code Quality
- The overall structure is clear and logically organized. 
- The use of type hints in the function signature enhances readability.

### Bugs
- The code does not handle cases where the GitHub repository does not exist or the owner/repo names are incorrect. A specific error message for this case should be implemented.
- The return type of the function is specified as `str`, but in case of an error, it returns an empty string. It may be better to return `None` or raise an exception to signal errors more clearly.

### Anti-Patterns
- The use of magic numbers (e.g., `max_depth`) could be replaced with a constant for better readability.
- The repeated logging of exceptions could be encapsulated in a helper function to reduce redundancy.

### Improvements
- Consider using a dedicated exception for GitHub-specific errors.
- Implement more granular logging for different types of errors.
- The `ignore_dirs` could be defined outside the function to avoid redefining it on each call.

### Compliance
- The code adheres to PEP 8 style guidelines, but adding docstrings for the module and additional comments would enhance maintainability.

## Updated Code
```python
import os
import requests
import streamlit as st
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)

# Ensure environment variable is set for GITHUB_KEY
GITHUB_KEY = os.getenv('GITHUB_KEY')
if not GITHUB_KEY:
    logging.error("GITHUB_KEY environment variable not set.")
    raise ValueError("GITHUB_KEY environment variable not set.")

# Constants
IGNORE_DIRS = {'public', 'images', 'media', 'assets'}
MAX_DEPTH = 10

def get_file_tree(owner: str, repo: str, path: str = "", level: int = 0, max_depth: int = MAX_DEPTH) -> str:
    """
    Fetch and print the tree structure of a GitHub repository, ignoring specific folders.

    Parameters:
    - owner: The username of the repository owner.
    - repo: The name of the repository.
    - path: The path to fetch. Leave empty to fetch the root directory.
    - level: The current depth in the tree structure.
    - max_depth: The maximum depth to recurse into directories.

    Returns:
    - str: The tree structure as a string or None if an error occurred.
    """
    if level > max_depth:
        return ""

    api_url = f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"
    headers = {'Authorization': f'token {GITHUB_KEY}'}

    output = ""

    try:
        response = requests.get(api_url, headers=headers, verify=True)
        response.raise_for_status()
        items = response.json()

        if isinstance(items, list):
            for item in items:
                if item['name'] in IGNORE_DIRS:
                    continue

                item_name = f"{' ' * (level * 2)}- {item['name']}"
                output += f"{item_name}\n"

                if item['type'] == 'dir':
                    output += get_file_tree(owner, repo, item['path'], level + 1, max_depth)

        return output

    except requests.exceptions.HTTPError as http_err:
        logging.error(f"HTTP error occurred: {http_err}")
    except requests.exceptions.ConnectionError as conn_err:
        logging.error(f"Connection error occurred: {conn_err}")
    except requests.exceptions.Timeout as timeout_err:
        logging.error(f"Timeout error occurred: {timeout_err}")
    except requests.exceptions.RequestException as req_err:
        logging.error(f"Request error: {req_err}")
    except ValueError:
        logging.error("Error: Unable to parse the response from GitHub.")
    except Exception as e:
        logging.error(f"Unexpected error occurred: {str(e)}")
    
    return None




# src/review_crew.py



## Project Name
code_challenge_reviewer.

## Path
src/review_crew.py.

## Explain This
This code defines a `ReviewCrew` class responsible for handling the review process of a specified file within a GitHub repository. It initializes with the repository's details, appends review results to a markdown file, and executes the review process using defined agents and tasks to gather content and perform reviews.

## Code Review
### Code Quality
- The code is generally well-structured and readable. It uses clear naming conventions for classes and methods, making it easy to understand the purpose of each component.
- The logging setup is appropriately done, allowing for easy debugging and monitoring of errors.

### Bugs
- There are no evident bugs in the code. However, error handling could be enhanced. For example, in the `append_review_to_file` method, the logger captures errors, but it would be beneficial to provide more context in the log message (e.g., the file path being written to).

### Anti-Patterns
- The method `run` has multiple responsibilities: it initializes agents, tasks, and the crew, and then executes the review. This violates the Single Responsibility Principle (SRP). It would be better to break this method into smaller, focused methods.

### Improvements
1. **Error Handling**: Enhance error messages to provide more context.
2. **Method Decomposition**: Refactor the `run` method to separate the initialization of agents, tasks, and the execution of the review.
3. **Docstrings**: While the class and methods have docstrings, consider adding more detailed explanations or examples where appropriate to enhance code documentation.
4. **Type Hinting**: Adding type hints for method parameters and return types would improve code readability and maintainability.

### Compliance
- The code follows PEP 8 style guidelines mostly, but a few lines exceed the recommended line length. It is advisable to keep lines under 79 characters for better readability.
- The logging practice is compliant with standard practices, ensuring that critical operations are logged.

## Updated Code
```python
import os
import re
import streamlit as st
import logging
from crewai import Crew
from agents import Agents
from tasks import Tasks

# Create a custom logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# Create handlers
console_handler = logging.StreamHandler()
console_handler.setLevel(logging.DEBUG)

# Create formatters and add them to the handlers
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)

# Add handlers to the logger
logger.addHandler(console_handler)


class ReviewCrew:
    """
    Class to handle the review process for a given file in a GitHub repository.
    """

    def __init__(self, owner: str, repo: str, path: str, output: str):
        """
        Initializes the ReviewCrew with the repository details.

        Parameters:
            owner (str): The owner of the repository.
            repo (str): The name of the repository.
            path (str): The path of the file to review.
            output (str): The path of the single file with all the repo files reviewed.
        """
        self.owner = owner
        self.repo = repo
        self.path = path
        self.output = output
        self.output_placeholder = st.empty()

    def append_review_to_file(self, result: str) -> None:
        """
        Appends the explain and the review result to a markdown file.

        Parameters:
            result (str): The str containing the explain and the review results in markdown format.
        """
        # Create directory path using owner and repo
        dir_path = os.path.join(self.owner, self.repo)
        os.makedirs(dir_path, exist_ok=True)

        # Create a file with the current date as its name
        file_path = os.path.join(dir_path, self.output)

        try:
            with open(file_path, 'a') as file:
                file.write(f"\n\n# {self.repo} - {self.path}\n\n")
                file.write(result)
        except Exception as e:
            logger.error(f"Error writing to file {file_path}: {e}")

    def initialize_agents(self) -> tuple:
        """
        Initializes the agents required for the review process.

        Returns:
            tuple: Contains initialized content and review agents.
        """
        agents = Agents()
        return agents.content_agent(), agents.review_agent()

    def initialize_tasks(self, content_agent, review_agent) -> tuple:
        """
        Initializes the tasks for content and review.

        Returns:
            tuple: Contains initialized content and review tasks.
        """
        tasks = Tasks()
        content_task = tasks.content_task(agent=content_agent, owner=self.owner, repo=self.repo, path=self.path)
        review_task = tasks.review_task(agent=review_agent, repo=self.repo, path=self.path, context=[content_task])
        return content_task, review_task

    def run(self) -> str:
        """
        Runs the review process using the defined agents and tasks.
        """
        try:
            content_agent, review_agent = self.initialize_agents()
            content_task, review_task = self.initialize_tasks(content_agent, review_agent)

            # The Crew
            crew = Crew(
                agents=[content_agent, review_agent],
                tasks=[content_task, review_task],
                verbose=2,
                telemetry=False
            )

            # Run the crew
            kickoff_result = crew.kickoff()

            str_result = str(kickoff_result).strip()
            result = re.sub(r'^```markdown|```$', '', str_result, flags=re.DOTALL)

            self.append_review_to_file(f"\n\n{result}\n\n")
            self.output_placeholder.code(f"\n\n{result}\n\n", language='markdown')

            return result

        except Exception as e:
            logger.error(f"Error running ReviewCrew: {e}")




# src/tasks.py




## Project Name
code_challenge_reviewer.

## Path
src/tasks.py.

## Explain This
This code defines a `Tasks` class that contains methods to create various tasks related to reviewing files in a repository. It includes methods for creating review tasks, getting file paths from a directory structure, and fetching file content using the GitHub API. Each method constructs a `Task` object with a specific description and context, handling exceptions and logging errors where necessary.

## Code Review
### Code Quality
- The code is generally well-structured and follows Python conventions. However, it could benefit from some refactoring for improved readability and maintainability.
- The inline documentation is clear and informative, providing a good understanding of the purpose of each method.

### Bugs
- There are no apparent bugs, but the error handling in the `except` blocks could be enhanced. Currently, the methods return `None` in the case of an error, which may not give enough information to the caller about what went wrong.

### Anti-Patterns
- The use of bare `except` statements can be considered an anti-pattern as it captures all exceptions, making debugging difficult. It is better to catch specific exceptions.
- The long multi-line strings in the `description` fields make it difficult to read and maintain. These could be refactored into separate functions or constants.

### Improvements
- Improve error handling by raising exceptions or returning error messages to inform the caller about issues rather than returning `None`.
- Refactor the long descriptions into separate constants or helper functions to enhance readability.
- Consider using type hints for the return types more consistently across all methods.

### Compliance
- The code is compliant with PEP 8 standards in terms of naming conventions and structure. However, it could further adhere to best practices by implementing the suggested improvements.

## Updated Code
```python
from crewai import Task
import logging
from crewai import Agent

class Tasks:
    """
    Class to create and manage different types of tasks.
    """

    def review_task(self, agent: Agent, repo: str, path: str, context: str) -> Task:
        """
        Creates a review task for a given file.

        Parameters:
            agent (Agent): The agent responsible for performing the review.
            repo (str): The name of the repository.
            path (str): The file path.
            context (str): The context for the task.

        Returns:
            Task: Configured task for performing the review.
        """
        try:
            description = f"""
                Review the given file and provide detailed feedback and a code review to ensure it adheres to industry code quality standards.

                - Take the file path and file contents from `content_agent`.
                - Provide a detailed code review with feedback on the following aspects:
                   * Code Quality
                   * Bugs
                   * Anti-Patterns
                   * Improvements
                   * Compliance
                - Make necessary improvements to the file content and return the updated content as `updated_code`.

                Return the following values in the markdown content output:

                - Project Name: {repo}.
                - Path: {path}.
                - Explain This: generate documentation for this code, explain the entire code in a few lines.
                - Code Review: detailed explain the code review for this code, provide feedback on the code quality, bugs, anti-patterns, improvements, and compliance.
                - Updated Code: updated code of file after making code review and changes.

                The attributes returned must be in markdown format, as heading h2 or ## and the value as its nested text.

                The `Updated Code` output string must be a string in python format. This `Updated Code` output string should be involved by backticks such as ```python updated_code_output ```.

                Only return the explained and reviewed file content. If there are multiple explains and reviews, return the entire reviewed file content in markdown format.

                Task output must be a string in markdown format and ensure the markdown content is accurate and well-structured.
            """
            return Task(agent=agent, description=description, context=context, expected_output="Only return the string output in markdown format and ensure the markdown content is accurate and well-structured.")
        except Exception as e:
            logging.error(f"Error creating review task: {e}")
            raise

    def get_file_path_task(self, agent: Agent, file_tree: str, repo_directory: str, repo_structure: str, repo_file_sample: str, repo_fullpath_sample: str, repo_output_sample: str) -> Task:
        """
        Creates a task to get the file path from a given tree structure.

        Parameters:
            agent (Agent): The agent responsible for performing the task.
            file_tree (str): The tree structure of the folder.
            repo_directory (str): The user input (file or folder name).

        Returns:
            Task: Configured task for extracting file paths.
        """
        try:
            description = f"""
                You are given a tree structure of folder and repo_directory. First, you have to decide whether it is a folder or file from the given tree structure of a folder.

                Follow this approach:

                - If it's a file then return array with 1 element which contains the full path of that file in this folder structure.
                - If it's a folder then return array of paths of sub files inside that folder. If there is a subfolder in given folder, then return paths for those files as well.
                - If repo_directory is not present in given tree structure then just return an empty array.

                Please return the FULL path of a given file in the given folder tree structure. For example, if the tree structure looks like this:

                {repo_structure}

                Then the full path of {repo_file_sample} will be "{repo_fullpath_sample}".

                DON'T send every file content at once, send it one by one to review_agent.

                Here is the tree structure of the folder:

                {file_tree}

                Here is user input:

                {repo_directory}

                NOTE: ONLY RETURN ARRAY OF PATHS WITHOUT ANY EXTRA TEXT IN RESPONSE.
            """
            return Task(agent=agent, description=description, expected_output=f"ONLY an array of paths.\nFor example:\n{repo_output_sample}")
        except Exception as e:
            logging.error(f"Error creating file path task: {e}")
            raise

    def content_task(self, agent: Agent, owner: str, repo: str, path: str) -> Task:
        """
        Creates a task to fetch file content using the GitHub API.

        Parameters:
            agent (Agent): The agent responsible for performing the task.
            owner (str): The owner of the repository.
            repo (str): The name of the repository.
            path (str): The file path.

        Returns:
            Task: Configured task for fetching file content.
        """
        try:
            description = f"""
                You are given a file path and you have to get the content of the file and file name using the GitHub API.

                Here is the file path:

                {path}

                Here is the owner name:

                {owner}

                Here is the repo name:

                {repo}

                Don't return anything except the filename and content.
            """
            return Task(agent=agent, description=description, expected_output="filename and content of the given file")
        except Exception as e:
            logging.error(f"Error creating content task: {e}")
            raise
```




# src/tools.py




## Project Name
code_challenge_reviewer.

## Path
src/tools.py.

## Explain This
This code defines a utility class `Tools` that fetches the content of a specified file from a GitHub repository. It uses the GitHub API to retrieve file data, ensuring the file size and line count are within configurable limits. The method `get_file_contents` handles authorization, error management, and decodes the Base64 content of the file for further use.

## Code Review
### Code Quality
The code is generally well-structured, with clear function separation and documentation. However, there are areas for improvement regarding error handling and code readability.

### Bugs
1. If the GitHub API response does not contain a `size` key, the code will raise a `KeyError`. This should be handled more gracefully.
2. The method does not handle the case where the file is not found (404 error), which should be specifically addressed.

### Anti-Patterns
1. Using a static method for a utility function is acceptable, but consider whether a class instance might provide better encapsulation for potential future enhancements.
2. The use of hard-coded API version in the headers may lead to issues if the version changes in the future. It would be better to define it as a constant at the top.

### Improvements
1. Improve error handling for specific API response codes (e.g., 404 Not Found).
2. Refactor the code to remove repetitive error handling logic by creating helper functions for error responses.
3. Consider logging errors instead of simply returning error messages, which can aid in debugging.
4. Add type hints to function parameters and return types for better clarity and compliance with modern Python practices.
5. Use f-strings for string concatenation for better performance and readability.

### Compliance
The code adheres to general Python coding standards but could further comply with PEP 8 by ensuring consistent spacing and line lengths. The use of constants for configurable values is good practice.

## Updated Code
```python
import os
import requests
import base64
from langchain_community.tools import tool

# Ensure environment variable is set for GITHUB_KEY
GITHUB_KEY = os.getenv('GITHUB_KEY')

if not GITHUB_KEY:
    raise EnvironmentError("GITHUB_KEY environment variable not set")

# Configurable thresholds
MAX_FILE_SIZE = int(os.getenv('MAX_FILE_SIZE', 1000000))  # 1 MB
MAX_LINE_COUNT = int(os.getenv('MAX_LINE_COUNT', 500))  # 500 lines
GITHUB_API_VERSION = '2022-11-28'

class Tools:
    @staticmethod
    @tool("get file contents from given file path")
    def get_file_contents(path: str, owner: str, repo: str) -> str:
        """
        Fetches the content of a given file from GitHub using the provided path, owner, and repository name.

        Parameters:
            path (str): The file path or URL.
            owner (str): The owner of the repository.
            repo (str): The name of the repository.

        Returns:
            str: The content of the file or an error message.
        """
        # Construct the API URL
        api_url = path if path.startswith("https://") else f"https://api.github.com/repos/{owner}/{repo}/contents/{path}"

        # Add the Authorization header with the token
        headers = {
            'Authorization': f'token {GITHUB_KEY}',
            'X-GitHub-Api-Version': GITHUB_API_VERSION
        }

        try:
            response = requests.get(api_url, headers=headers)
            response.raise_for_status()  # Raise an HTTPError for bad responses (4xx and 5xx)

            file_content = response.json()

            # Check the size of the file
            if 'size' not in file_content or file_content['size'] > MAX_FILE_SIZE:
                return "Skipped: File size is greater than the configured limit."

            # Decode the Base64 encoded content
            content_decoded = base64.b64decode(file_content['content'])
            content_str = content_decoded.decode('utf-8')

            # Check the number of lines in the file
            if len(content_str.split('\n')) > MAX_LINE_COUNT:
                return "Skipped: File contains more lines than the configured limit."

            return content_str

        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 404:
                return "Error: File not found."
            return f"Error: HTTP error occurred - {str(e)}"
        except requests.exceptions.RequestException as e:
            return f"Error: Request failed - {str(e)}"
        except KeyError as e:
            return f"Error: Missing expected data - {str(e)}"
        except base64.binascii.Error as e:
            return f"Error: Base64 decoding failed - {str(e)}"
        except Exception as e:
            return f"Error: An unexpected error occurred - {str(e)}"
```


