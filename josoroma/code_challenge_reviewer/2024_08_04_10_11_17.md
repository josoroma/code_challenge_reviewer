

# code_challenge_reviewer - src/agents.py



## project_name
code_challenge_reviewer.

## path
src/agents.py.

## explain_this
This code defines a class `Agents` responsible for creating and managing different types of agents, specifically for code review, path extraction, and content fetching using GitHub's API. It also includes a `StreamToExpander` class to handle output streaming to a UI component, filtering out specific data and managing color-coded notifications.

## code_review
### Code Quality
The code is generally well-structured and follows a class-based design. The use of docstrings for class and method descriptions enhances readability and provides a clear understanding of the intended functionality. However, there are some areas where improvements can be made for clarity and maintainability.

### Bugs
No significant bugs are present in the implementation; however, error handling could be improved. Currently, exceptions are printed out without further handling, which may lead to silent failures or uninformative logs.

### Anti-Patterns
1. **Error Handling**: The exception handling in the agent creation methods merely prints errors. A better practice would involve logging these errors or raising custom exceptions to allow upstream handling.
2. **Magic Strings**: The code contains hardcoded strings, such as role descriptions and goals. These could be defined as constants to avoid repetition and make future updates easier.

### Improvements
1. **Logging**: Instead of printing errors directly, consider using a logging framework (e.g., Python's `logging` module) to provide better control over log levels and outputs.
2. **Constants for Magic Strings**: Define constants for the roles and goals to improve maintainability. This not only avoids magic strings but also enhances code clarity.
3. **Type Hinting**: Adding type hints for method return types would improve code readability and help with static analysis tools.

### Compliance
The code complies with basic Python coding standards but could benefit from stricter adherence to PEP 8 guidelines, especially concerning line lengths and whitespace usage. Additionally, the regular expressions used could be extracted into named constants for better readability.

## updated_code
```python
import re
import logging
from crewai import Agent
import streamlit as st
from tools import Tools

# Constants to avoid magic strings
ROLE_REVIEW_AGENT = 'Senior Software Developer'
ROLE_PATH_AGENT = "File Path Extractor"
ROLE_CONTENT_AGENT = "GitHub API Expert"

GOAL_REVIEW_AGENT = 'Perform detailed code reviews on the provided file to ensure it adheres to industry code quality standards. The code review should focus on the following aspects: evaluate code quality, identify bugs, spot anti-patterns, recommend improvements and ensure compliance.'
GOAL_PATH_AGENT = "Get the tree structure of folder and return full paths of the given file or files of given folder in array format"
GOAL_CONTENT_AGENT = "Get the content of given file using GitHub API"

class Agents:
    """
    Class to create and manage different types of agents.
    """

    def review_agent(self) -> Agent:
        """
        Creates a review agent for code reviews.
        
        Returns:
            Agent: Configured agent for performing code reviews.
        """
        try:
            return Agent(
                role=ROLE_REVIEW_AGENT,
                goal=GOAL_REVIEW_AGENT,
                backstory="You are a Senior Software Developer at a leading tech company, responsible for maintaining high code quality standards across the organization. As part of your role, you are tasked with conducting thorough code reviews on given file contents. Your goal is to ensure the code meets industry standards and follows best practices specific to the technologies in use.",
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error(f"Error creating review agent: {e}")
            return None

    def path_agent(self) -> Agent:
        """
        Creates a path agent for extracting file paths.
        
        Returns:
            Agent: Configured agent for extracting file paths.
        """
        try:
            return Agent(
                role=ROLE_PATH_AGENT,
                goal=GOAL_PATH_AGENT,
                backstory="You're a file path extractor who has created several file paths from given tree structures",
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error(f"Error creating path agent: {e}")
            return None

    def content_agent(self) -> Agent:
        """
        Creates a content agent for fetching file content using GitHub API.
        
        Returns:
            Agent: Configured agent for fetching file content using GitHub API.
        """
        try:
            return Agent(
                role=ROLE_CONTENT_AGENT,
                goal=GOAL_CONTENT_AGENT,
                backstory="You're a GitHub API expert who has extracted many file contents using GitHub's API",
                verbose=True,
                allow_delegation=False,
                tools=[Tools.get_file_contents],
            )
        except Exception as e:
            logging.error(f"Error creating content agent: {e}")
            return None

class StreamToExpander:
    def __init__(self, expander):
        self.expander = expander
        self.buffer = []
        self.colors = ['red', 'green', 'blue', 'orange']  # Define a list of colors
        self.color_index = 0  # Initialize color index

    def write(self, data: str):
        # Filter out ANSI escape codes using a regular expression
        cleaned_data = re.sub(r'\x1B\[[0-9;]*[mK]', '', data)

        # Check if the data contains 'task' information
        task_match_object = re.search(r'\"task\"\s*:\s*\"(.*?)\"', cleaned_data, re.IGNORECASE)
        task_match_input = re.search(r'task\s*:\s*([^\n]*)', cleaned_data, re.IGNORECASE)
        
        task_value = None
        
        if task_match_object:
            task_value = task_match_object.group(1)
        elif task_match_input:
            task_value = task_match_input.group(1).strip()

        if task_value:
            st.toast(":robot_face: " + task_value)
            
        self.buffer.append(cleaned_data)

        if "\n" in data:
            self.expander.code(''.join(self.buffer), language='bash')
            self.buffer = []


