

# code_challenge_reviewer - src/agents.py



## Project Name: code_challenge_reviewer.

## Path: src/agents.py.

## Explain This:

This script defines a module that includes classes for creating and managing different types of agents for code reviews, path extraction, and content fetching using the GitHub API. It also includes a utility class for streaming data to a Streamlit expander component.

1. **Imports and Logging**: The necessary modules are imported, and logging is configured.
2. **Agents Class**: This class includes methods to create different agents (`review_agent`, `path_agent`, `content_agent`) with specific roles and goals.
3. **StreamToExpander Class**: This class helps in streaming log data to a Streamlit expander while filtering out ANSI escape codes and displaying task-related information as toasts.

## Code Review:

### Code Quality:
1. **Docstrings**: The code contains appropriate docstrings for classes and methods which enhance readability.
2. **Error Handling**: The use of try-except blocks for error handling is good practice but can be improved by providing more specific exception handling and adding more context to the error messages.
3. **Modularity**: The code is well-organized into classes and methods, making it modular and easier to maintain.

### Bugs:
1. **Buffer Handling in StreamToExpander**: The buffer is not cleared correctly in the `write` method, which can cause performance issues if large amounts of data are processed.

### Anti-Patterns:
1. **Hardcoded Values**: The list of colors and the initial color index in `StreamToExpander` are hardcoded. These should be configurable.
2. **Silent Failures**: The methods return `None` on exceptions without giving detailed information, which can make debugging difficult.

### Improvements:
1. **Logging Enhancements**: Improve logging by adding more context to the error messages.
2. **Configuration**: Make hardcoded values configurable.
3. **Buffer Management**: Ensure that the buffer is managed correctly to avoid performance issues.
4. **Specific Exception Handling**: Use more specific exception handling instead of a general `Exception`.

### Compliance:
1. **PEP 8**: The code generally adheres to PEP 8 standards. Minor improvements could be made in import ordering and line lengths.

## Updated Code:

```python
import re
import logging
from crewai import Agent
import streamlit as st
from tools import Tools

# Set up logging configuration
logging.basicConfig(level=logging.ERROR)

class Agents:
    """
    Class to create and manage different types of agents.
    """

    def review_agent(self):
        """
        Creates a review agent for code reviews.

        Returns:
            Agent: Configured agent for performing code reviews.
        """
        try:
            return Agent(
                role='Senior Software Developer',
                goal='Perform detailed code reviews on the provided file to ensure it adheres to industry code quality standards. The code review should focus on the following aspects: evaluate code quality, identify bugs, spot anti-patterns, recommend improvements and ensure compliance.',
                backstory="You are a Senior Software Developer at a leading tech company, responsible for maintaining high code quality standards across the organization. As part of your role, you are tasked with conducting thorough code reviews on given file contents. Your goal is to ensure the code meets industry standards and follows best practices specific to the technologies in use.",
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error(f"Error creating review agent: {e}")
            return None

    def path_agent(self):
        """
        Creates a path agent for extracting file paths.

        Returns:
            Agent: Configured agent for extracting file paths.
        """
        try:
            return Agent(
                role="File Path Extractor",
                goal="Get the tree structure of folder and return full paths of the given file or files of given folder in array format",
                backstory="You're a file path extractor who has created several file paths from given tree structures",
                allow_delegation=False,
                verbose=True,
            )
        except Exception as e:
            logging.error(f"Error creating path agent: {e}")
            return None

    def content_agent(self):
        """
        Creates a content agent for fetching file content using GitHub API.

        Returns:
            Agent: Configured agent for fetching file content using GitHub API.
        """
        try:
            return Agent(
                role="GitHub API Expert",
                goal="Get the content of given file using GitHub API",
                backstory="You're a GitHub API expert who has extracted many file contents using GitHub's API",
                verbose=True,
                allow_delegation=False,
                tools=[Tools.get_file_contents],
            )
        except Exception as e:
            logging.error(f"Error creating content agent: {e}")
            return None

class StreamToExpander:
    def __init__(self, expander, colors=None):
        self.expander = expander
        self.buffer = []
        self.colors = colors if colors else ['red', 'green', 'blue', 'orange']  # Colors are now configurable
        self.color_index = 0  # Initialize color index

    def write(self, data):
        # Filter out ANSI escape codes using a regular expression
        cleaned_data = re.sub(r'\x1B\[[0-9;]*[mK]', '', data)

        # Check if the data contains 'task' information
        task_match_object = re.search(r'\"task\"\s*:\s*\"(.*?)\"', cleaned_data, re.IGNORECASE)
        task_match_input = re.search(r'task\s*:\s*([^\n]*)', cleaned_data, re.IGNORECASE)

        task_value = None

        if task_match_object:
            task_value = task_match_object.group(1)
        elif task_match_input:
            task_value = task_match_input.group(1).strip()

        if task_value:
            st.toast(":robot_face: " + task_value)

        self.buffer.append(cleaned_data)

        if "\n" in data:
            self.expander.code(''.join(self.buffer), language='bash')
            self.buffer = []

    def clear_buffer(self):
        """Clears the buffer to free memory."""
        self.buffer = []
```

